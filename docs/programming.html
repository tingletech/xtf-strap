<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="EN">
  
<head>
  <title>XTF Programming Guide</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" href="library/xtfDocStyle.css" type="text/css" />
</head>

<body bgcolor="#FFFFFF" text="#101010" >
  
<div class="BaseStyle"> 
  <p class="DocTitle" align="center">XTF Programming Guide</p>
  <p class="Heading1">Table of Contents</p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <ul class="NoBullets">
    <li> <b><a href="#Introduction">Introduction</a></b>     <br/>
      <br/>
    </li>
    <li> <b><a href="#textIndexer_Prog">textIndexer Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#textIndexer_DocSelector_Prog">Document Selector Programming</a></li>
        <li><a href="#textIndexer_PreFilter_Prog">Pre-Filter Programming</a></li>
      </ul>
      <br/>
    </li>
    <li> <b><a href="#crossQuery_Prog">crossQuery Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#crossQuery_QueryParser_Prog">Query Parser Programming</a></li>
        <li><a href="#crossQuery_ResultFormatter_Prog">Result Formatter Programming</a></li>
        <li><a href="#Spelling">Spelling Correction</a><br/>
          <ul class="NoBullets">
            <li> <a href="#Spelling_Dict">Creating a Spelling Correction Dictionary</a></li>
            <li> <a href="#Spelling_Activation">Activating Spelling Correction</a></li>
            <li> <a href="#Spelling_Formatting">Formatting the Suggestions</a></li>
          </ul>
        </li>
        <li><a href="#Faceted_Browsing">Faceted Browsing</a><br/>
          <ul class="NoBullets">
            <li><a href="#Faceted_MetaReq">Meta-data Requirements</a></li>
            <li><a href="#Faceted_Query">Adding Facets to Your Stylesheets</a></li>
            <li><a href="#Facet_Group_Selection">Group Selection</a></li>
            <li><a href="#Facet_Hierarchical">Hierarchical Facets</a><br/>
            </li>
          </ul>
        </li>
        <li><a href="#crossQuery_Common_Prog">Other Common Tasks</a></li>
      </ul>
      <br/>
    </li>
    <li> <b><a href="#dynaXML_Prog">dynaXML Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#dynaXML_DocReqParser_Prog">Document Request Parser Programming</a></li>
        <li><a href="#dynaXML_DocFormatter_Prog">Document Formatter Programming</a></li>
        <li><a href="#dynaXML_Common_Prog">Other Common Tasks</a></li>
      </ul>
      <br/>
    </li>
    <li> <b><a href="#Common_Prog">Common crossQuery/dynaXML Programming Tasks</a></b> 
      <ul class="NoBullets">
        <li><a href="#Common_ErrorGen_Prog">Error Generator Programming</a></li>
        <li><a href="#Common_PassThrough">Pass-Through Configuration Tags</a></li>
        <li><a href="#Common_Session_State">Tracking Session State</a></li>
        <li><a href="#Common_Exec">Calling Command-line Tools</a></li>
        <li><a href="#Common_FileUtils">Checking File Existence, Length, and Modification Time</a></li>
        <li><a href="#Common_Redirect">Redirecting to another URL</a></li>
      </ul>
      <br/>
    </li>
  </ul>
  <p class="Heading1">Introduction<a name="Introduction"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  This guide describes how to customize the operation of the E<b>X</b>tensible 
  <b>T</b>ext <b>F</b>ramework (<b><i>XTF</i></b>) This document assumes that 
  you have completed the basic installation and configuration described in the 
  <a href="deployment.html">XTF Deployment Guide</a>, 
  and that their correct operation has been verified. <br/>
  <br/>
  The XTF system consists of Java Servlets and tools that permit users to perform 
  Web-based searching and retrieval of electronic documents. The basic organization 
  of the XTF components can be illustrated as follows: 
  <p align="center"> <a name="SummaryDiagram"></a> <img src="art/SummaryDiagram.gif" alt="Summary Diagram"/><br/>
    Figure 1: Extensible Text Framework (XTF) Overview </p>
  In this diagram, the basic flow of information is left to right. Document retrieval 
  begins with a Web-based user search query. The <i><b>crossQuery</b></i> servlet 
  checks the query against an index of available documents, and produces a list 
  of matching documents for display in a web browser. Selecting a document from 
  the search results page invokes the <i><b>dynaXML</b></i> servlet, which retrieves 
  and formats the actual document for display in a web browser. The <b><i>textIndexer</i></b> 
  tool shown at the bottom is used to update the document search index whenever 
  documents in the library are added, removed, or updated. <br/>
  <br/>
  The remainder of this document will examine how to customize the XTF tools and 
  servlets by reprogramming the XSLT templates that define their behavior. 
  <p class="Heading1">textIndexer Programming<a name="textIndexer_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  As mentioned above in the introduction, the purpose of the <b><i>textIndexer</i></b> 
  tool is to create or update a document search index whenever documents are updated, 
  added to, or removed from the document library. If we would isolate and zoom 
  in on the <b><i>textIndexer</i></b> portion of the <a href="#SummaryDiagram">XTF 
  Overview Diagram</a> shown above, we'd see something like this: <br/>
  <p align="center"> <img src="art/textIndexerDataFlow.gif" alt="textIndexer Data Flow"/><br/>
    Figure 2: Data Flow within the <b><i>textIndexer</i></b> Tool </p>
  <p>What the diagram shows, is that the <b><i>textIndexer</i></b> uses a <b>Document 
    Selector</b> stylesheet to select which files in the document library need 
    to be indexed. For non-XML document files, the text to index is extracted 
    and converted to XML. This base XML is then processed by the <b>Document Pre-Filter</b> 
    stylesheet to add additional meta-data and/or sectioning information to the 
    text. The resulting filtered XML is then passed on to the actual <b><i>Text 
    Indexer Engine</i></b>, which breaks the text up into smaller overlapping 
    chunks and then adds them to a Lucene based word index. The index can then 
    be used by the <b><i>crossQuery</i></b> servlet to quickly locate files in 
    the document library containing any text requested by the user. Optionally, 
    the <b><i>dynaXML</i></b> servlet can also use the index to highlight in context 
    any matches in the original XML documents when they are viewed. </p>
  <p>The <b><i>textIndexer</i></b> is capable of handling many documents, of various 
    types, that are filtered in different ways. Here is a diagram showing how 
    the decisions are made.</p>
  <p align="center"> <img src="art/textIndexerDecisionTree.gif" alt="textIndexer Decision Tree"/><br/>
    Figure 3: Decision Tree of the <b><i>textIndexer</i></b> Tool </p>
  <p> The <span class="Code">textIndexer.conf</span> file, the <b>Document Selector</b> 
    stylesheet, and the <b>Pre-filter</b> stylesheet together define how the <b><i>textIndexer</i></b> 
    performs the document indexing process. A complete discussion of the <span class="Code">textIndexer.conf</span> 
    file appears in the <a href="deployment.html">XTF 
    Deployment Guide</a>, and so will not be discussed in any great depth here. 
    The inner workings of the <b>Document Selector</b> and <b>Pre-Filter</b> stylesheets 
    however, are the subject of the following subsections. </p>
  <div class="IndentL"> 
    <p class="Heading2">Document Selector Programming<a name="textIndexer_DocSelector_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    The primary purpose of the <b><i>textIndexer</i></b> <b>Document Selector</b> 
    is to select which files in the document library are to be indexed. Since 
    the <b>Document Selector</b> is an XSLT stylesheet, its input is in fact an 
    XML fragment that identifies a single directory in the document library and 
    the files that it contains. The <b>Document Selector</b> stylesheet is invoked 
    one time for each subdirectory encountered in the document library, and the 
    input it receives looks as follows: 
    <pre class="Sample"><b>&lt;directory dirPath="<span class="MacroCode">DirectoryPath</span>"&gt;

    &lt;file fileName="<span class="MacroCode">FileName1</span>"/&gt;
    &lt;file fileName="<span class="MacroCode">FileName2</span>"/&gt;
               â€¦
    &lt;file fileName="<span class="MacroCode">FileNameN</span>"/&gt;

&lt;/directory&gt;</b></pre>
    <p> The<span class="Code"> &lt;directory...&gt; </span> tag identifies a single 
      directory in the document library, and the <b><span class="MacroCode">DirectoryPath</span></b> 
      attribute specifies its absolute file system path. Within the <span class="Code"> 
      &lt;directory...&gt; </span> tag, each of the <span class="Code">&lt;file.../&gt; 
      </span>entries identifies one of files found in the directory. Note that 
      <b><span class="MacroCode">FileName1</span></b> through <b><span class="MacroCode">FileNameN</span></b> 
      <i><b><u>do not</u></b></i> contain any path information, since the absolute 
      path that applies to all the file tags is already identified by <b><span class="MacroCode">DirectoryPath</span></b>.</p>
    <p>It is the responsibility of the <b>Document Selector</b> XSLT code to output 
      an XML fragment that identifies which of the files in the directory should 
      be indexed. This output XML fragment should take the following form:</p>
    <pre class="Sample"><b>&lt;indexFiles&gt;

    &lt;indexFile fileName      = "<span class="MacroCode">FileName</span>"
               <i>{</i>format       = &quot;<span class="MacroCode">FileFormatID</span>"<i>}</i>
               <i>{</i>preFilter    = &quot;<span class="MacroCode">PreFilterPath</span>"<i>}</i>
               <i>{</i>displayStyle = &quot;<span class="MacroCode">DocumentFormatterPath</span>"<i>}</i>/&gt;
                    â€¦

&lt;/indexFiles&gt;</b></pre>
    <p>Note that the output XML consists of a single<span class="Code"> &lt;indexFiles&gt; 
      </span>container tag and one<span class="Code"> &lt;indexFile.../&gt; </span>tag 
      for each document file that needs to be indexed. Within each of the<span class="Code"> 
      &lt;indexFile.../&gt; </span>tags, the following attributes are defined:</p>
    <div class="IndentLR"> <span class="Code">fileName</span><br/>
      This attribute identifies the name of a file to be indexed, and should be 
      one of the file names received in the input XML fragment. <br/>
      <br/>
      <span class="Code">format</span><br/>
      This is an optional attribute that defines the format of the file to be 
      indexed. At this time, XML, PDF, HTML, and Plain Text indexing is supported 
      by the <i><b>textIndexer</b></i> tool, and this attribute should be set 
      to the strings<span class="Code"> XML</span>,<span class="Code"> PDF</span>, 
      <span class="Code"> HTML</span>, or<span class="Code"> Text </span>respectively, 
      depending on the native format of the file. If this attribute is not specified, 
      the <i><b>textIndexer</b></i> will try to infer the file type based on the 
      extension for the file. <br/>
      <br/>
      <span class="Code">preFilter</span><br/>
      This is an optional attribute that defines the <b>Pre-Filter </b>stylesheet 
      that the <i><b>textIndexer</b></i> should use on this document file. If 
      not specified, the text for this file will not be filtered before indexing. 
      See the <i><b>textIndexer</b></i> <a href="#textIndexer_PreFilter_Prog">Pre-Filter 
      Programming</a> section for more details about document pre-filtering.<br/>
      <br/>
      <span class="Code">displayStyle</span><br/>
      This is an optional attribute that defines the <b>Document Formatter </b>stylesheet 
      associated with the given file. If specified, the <i><b>textIndexer</b></i> 
      will create a special cache that is used by the <i> <b>dynaXML</b></i> servlet 
      to display selected documents more quickly. If not specified, the cache 
      for the current file is not created. For more details, see the discussion 
      of <a href="underHood.html#LazyFiles">Lazy Document 
      Handling</a> in the <a href="underHood.html">XTF Under 
      the Hood</a> guide.</div>
    <p>Using these XML input and output specifications shown, a simple document 
      selector might look something like this:</p>
    <pre class="Sample">&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"&gt;

  &lt;xsl:template match="directory"&gt;
    &lt;indexFiles&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/indexFiles&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="file"&gt;
    &lt;xsl:if test="ends-with(@fileName,'.pdf')"&gt;
	  &lt;indexFile fileName="{@fileName}" format="PDF"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
    <p>In this simple <b>Document Selector</b> example, the first line establishes 
      the<span class="Code"> xsl </span>namespace used in the rest of the stylesheet. 
      Next, the<span class="Code"> &lt;xsl:template match=&quot;directory&quot;&gt; 
      </span>tag looks for the<span class="Code"> &lt;directory...&gt; </span>block 
      in the input XML, and writes out a corresponding<span class="Code"> &lt;indexFiles&gt; 
      </span>block to the output XML. Also the<span class="Code"> &lt;xsl:template&nbsp;match="file"&gt; 
      </span>template is applied to any tags found within the<span class="Code"> 
      &lt;directory...&gt; </span>block.</p>
    <p>The<span class="Code"> &lt;xsl:template&nbsp;match="file"&gt; </span>block 
      is the code that is actually responsible for selecting the files to be indexed. 
      In this example, only files that end in<span class="Code"> .pdf </span>are 
      passed on for indexing, and are assigned the format<span class="Code"> PDF</span>. 
      No <b>Pre-Filter</b> or <b>Document Formatter</b> stylesheets are defined, 
      and so the <i><b>textIndexer</b></i> will not pre-filter or pre-cache display 
      information for<span class="Code"> PDF </span>files.</p>
    <p>Selecting other file types for indexing is as simple as adding more<span class="Code"> 
      &lt;xsl:if...&gt; </span>clauses to the<span class="Code"> &lt;xsl:template 
      match=&quot;file&quot;&gt; </span>block, like this:</p>
    <pre class="Sample">          â€¦
  &lt;xsl:template match="file"&gt;
    &lt;xsl:if test="ends-with(@fileName,'.pdf')"&gt;
	  &lt;indexFile fileName="{@fileName}" format="PDF"/&gt;
    &lt;/xsl:if&gt;
    <b><font color="#990000">&lt;xsl:if test="ends-with(@fileName,'.xml')"&gt;
	  &lt;indexFile fileName     = "{@fileName}"
                 preFilter    = &quot;style/textIndexer/default/prefilter.xsl&quot;
                 displayStyle = &quot;style/dynaXML/docFormatter/default/docFormatter.xsl&quot;/&gt;
    &lt;/xsl:if&gt;</font></b>
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
    <p>This<span class="Code"> second &lt;xsl:if...&gt; </span>block passes XML 
      on files for indexing. Note that the<span class="Code"> &lt;indexFile...&gt; 
      </span>tag doesn't specify the file format, and so the <i><b>textIndexer</b></i> 
      is left to infer that the file type is XML from the file extension. Lastly, 
      the<span class="Code"> &lt;indexFile...&gt; </span>tag also defines a <b>Pre-Filter</b> 
      and a <b>Document Formatter</b> stylesheet for XML files.</p>
    <p>While this simple<b> Document Selector </b>example works, its file selection 
      rules are limited only to checking for certain file extensions. Clearly, 
      all the power of XSLT could be used to construct more complicated selection 
      criteria for files, including ignoring various directories, pulling in meta-data 
      from files or URLs, and so on. For a more complete example of a <b>Document 
      Selector</b> stylesheet, see the default <span class="Code"> style/textIndexer/docSelector.xsl</span> 
      stylesheet.</p>
  </div>
  <div class="IndentL"> 
    <p class="Heading2">Pre-Filter Programming<a name="textIndexer_PreFilter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    The primary purpose of <b><i>textIndexer</i></b> <b>Pre-Filters</b> is to 
    modify the XML representation of a document prior to indexing it. The pre-filter 
    used for any particular document is defined by the <b>Document Selector</b>. 
    The main aspects of programming a pre-filter are described in the following 
    six subsections. <br/>
    <div class="IndentLR"> 
      <p class="Heading3">Defining the XTF Namespace</p>
      <br/>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      For the <b><i>textIndexer</i></b> pre-filter to work properly, an<span class="Code"> 
      xtf: </span>namespace must be declared at the top of the pre-filter. To 
      do this, simply add the following attribute to the<span class="Code"> &lt;xsl:stylesheet<span class="BaseStyle">...</span>&gt; 
      </span>tag at the top of the pre-filter: <br/>
      <br/>
      <div class="Sample"> <span class="Code">xmlns:xtf="http://cdlib.org/xtf"</span> 
      </div>
      <br/>
      Defining an<span class="Code"> xtf: </span>namespace in this way and then 
      prefixing <b><i>textIndexer</i></b> specific attributes with it allows the 
      <b><i>textIndexer</i></b> to distinguish its own attributes from other ones 
      in the filtered document. </div>
    <div class="IndentLR"> 
      <p class="Heading3">Preventing Text from being Indexed</p>
      <br/>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      There will be times when the text within certain tags in the XML representation 
      for a document should not be indexed (e.g.: versioning information about 
      the original XML file format.) The XSLT pre-filter can be prevent such tags 
      and their associated text from being indexed. There are two possible ways 
      to do this: 
      <ol>
        <li class="ListItem"> Standard XSLT programming can be used to eliminate 
          the tag and its text entirely.<br/>        <br/>
        </li>

        <li class="ListItem"> A special <span class="Code">noindex</span> attribute 
          can be added to the tag to tell the <b><i>textIndexer</i></b> to ignore 
          its contents when indexing. </li>
      </ol>
      Eliminating certain tags through the use of standard XSLT techniques has 
      the advantage that it saves space. The tag's text is not added to the search 
      index, nor is it stored by the fast retrieval database for later display 
      by the <b><i>dynaXML</i></b> servlet. By contrast, the <span class="Code">noindex</span> 
      attribute simply prevents the tag's text from being indexed. The text is 
      still stored in the fast retrieval database so that the <b><i>dynaXML</i></b> 
      servlet can display the text if necessary. <br/>
      <br/>
      A snippet of code showing the use of the <span class="Code"> noindex </span> 
      attribute can be found in the sample <span class="Code"> preFilter.xml </span> 
      file that is included with the default XTF installation. It looks as follows: 
      <br/>
      <pre class="Sample"><b>&lt;xsl:template match="teiHeader"&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:noindex" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      Notice that the <span class="Code"> noindex </span> attribute when used 
      in the pre-filter is prefixed with <span class="Code"> xtf: </span>. This 
      is the namespace used in XTF tags and attributes to prevent collisions with 
      similarly named tags and attributes defined by other programs.<br/>
      <br/>
      Finally, it should be mentioned that the <span class="Code">noindex</span> 
      attribute has two forms: <br/>
      <br/>
      <div class="IndentLR"> 
        <pre class="Code">noindex = true/yes, false/no</pre>
      </div>
      and <br/>
      <br/>
      <div class="IndentLR"> 
        <pre class="Code">index   = false/no, true/yes</pre>
      </div>
      Both forms enable or disable indexing, but their logic is inverted so that 
      the XSLT programmer can choose the wording that makes the most sense in 
      any given situation. 
      <p class="Heading3">Controlling Proximity</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      If an XTF user specifies a list of words to search for, the <b><i>crossQuery</i></b> 
      servlet will rank any matching words that are closer together as better 
      matches than ones that are far apart. This is what is known as <b><i>proximity 
      searching</i></b>. <br/>
      <br/>
      There are times however when simple proximity matches will produce undesired 
      results. For example, consider the case where a query matches some words 
      in two different places in a document. For the first match, the words are 
      very close together but in two different chapters' tags. For the second 
      match, the words are all in the same chapter, but slightly further apart. 
      In this case, the proximity search mechanism will incorrectly give a higher 
      score to match with the words that are closer together but split across 
      two chapters. <br/>
      <br/>
      To correct for these kinds of situations, the pre-filter can insert a <b><i>proximity 
      break attribute</i></b> into a tag. Doing so effectively puts an infinite 
      distance between the tag with the break and the text before it, thus entirely 
      preventing proximity matches from being found that span the two tags. For 
      example, to solve the "proximity across chapters" problem described above, 
      a pre-filter might include some code like this: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="chapter"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:proximitybreak" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      In this example, the important code is on first and fourth lines. The first 
      line tells the pre-filter to look for "chapter" tags. And when it finds 
      one, the fourth line adds a proximity break attribute. Adding this code 
      to the pre-filter would ensure that proximity matches are never found that 
      span two "chapter" tags. <br/>
      <br/>
      Sometimes it may still be desirable to find proximity matches across sections, 
      but de-emphasize them compared to matches found entirely within a section. 
      In this case, the<span class="Code"> sectionBump </span>attribute can be 
      used in place of a proximity break. Unlike the<span class="Code"> proximityBreak 
      </span>tag, the<span class="Code"> sectionBump </span> tag can be told how 
      much distance (as a number of words) to introduce between two adjacent sections. 
      For example, this code: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="chapter"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sectionBump" select="10"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      would separate adjacent chapters from each other by ten words. Proximity 
      matches across chapters would still be found, but they would be considered 
      10 words further apart (and therefore less relevant) than similar matches 
      found entirely within a single section. <br/>
      <br/>
      Just as it may be desirable to de-emphasize proximity matches across adjacent 
      sections, it may also be desirable to control proximity matches across sentence 
      boundaries. To accomplish this, the sentenceBump attribute can be added 
      to a tag like this: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="DocText"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sentenceBump" select="5"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      In this example, a hypothetical tag under which all other document tags 
      and text exist has its sentenceBump value set to 5 words. This effectively 
      separates the end of one sentence from the beginning of the next by five 
      words. Doing so makes proximity matches across sentences less relevant than 
      a similar proximity match entirely within a single sentence. 
      <p class="Heading3">Sectioning Documents</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      Another attribute that can be added to document tags is the<span class="Code"> 
      <a href="tagRef.html#textIndexer_PreFilt_SectType">xtf:sectionType</a> </span>attribute. This attribute allows you to assign names 
      to tags within a document. Doing so would allow permit advanced user queries 
      that only search for text in specific section types. Consider the following 
      example: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="ChapterTitle"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sectionType" select="'ChapterTitle'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      This XSLT code simply labels the text indexed for a chapter title with a 
      "ChapterTitle" section type. With the text labeled in this manner, the query 
      page presented to the user could provide an advanced search option to look 
      for text only in chapter titles. We'll talk more about how to actually do 
      this in the section below on <a href="#crossQuery_QueryParser_Prog">programming 
      the <b><i>crossQuery</i></b> servlet's Query Parser Stylesheet</a>. <br/>
      <br/>
      One other thing to mention about <span class="Code">sectionType</span> attributes 
      is that they may be used in nested tags. The <b><i>textIndexer</i></b> maintains 
      an internal stack of nested section types, and correctly restores previous 
      section types when a given section/tag ends. If you are trying to represent
      hierarchical information in a section type, you can use the
      <span class="Code"><a href="tagRef.html#textIndexer_PreFilt_SectTypeAdd">xtf:sectionTypeAdd</a></span> 
      attribute on child elements to append to their parents' section type information.
      <p class="Heading3">Relevance Boost</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      There may be times when it is useful to boost or de-emphasize the relevance 
      of text in a particular part of a document. Consider the case where you 
      had a document that was a book of quotations. In such a document, it might 
      make sense to boost the relevance of the text in the actual quotations as 
      compared to any text that discussions the quotations. To facilitate this, 
      the <b><i>textIndexer</i></b> pre-filter provides a <b><i>wordBoost</i></b> 
      attribute. The following example illustrates its use: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="Quotation"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:wordboost" select="1.5"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      This XSLT code simply boosts text found in <span class="Code">Quotation</span> 
      tags to be 1.5 times more relevant than non-boosted text in the document. 
      Conversely, to de-emphasize text simply use a value between zero and one 
      (e.g., a boost of 0.5 would make text half as relevant when searching.) 
      <br/>
      <br/>
      As with <span class="Code">section</span> attributes, the wordboost attribute 
      may be used in nested tags. The <b><i>textIndexer</i></b> maintains an internal 
      stack of nested boost values, and correctly restores previous values when 
      a given section/tag ends. Note however that boost values in nested tags 
      <b><i>do not</i></b> accumulate. That is, a tag with a boost value of 1.5 
      will boost the relevance of its words by 1.5, regardless of the boost values 
      applied to any tags that contain it. 
      <p class="Heading3">Adding or Marking Meta-Data</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      There are times when it is useful to record Meta-Data for a document. Meta-Data 
      is simply information about a document that is not part of the document 
      text itself. The author name, document publication date, and document revision 
      are all examples of Meta-Data. The <b><i>textIndexer</i></b> system supports 
      the concept of Meta-Data through the use of the <span class="Code">meta</span> 
      attribute. Using the pre-filter to add this attribute to a tag causes name 
      of the tag and its contents to be recorded in a special Meta-Data section 
      of the index for the document. For example: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="PublicationInfo"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:meta" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      <p>This snippet of pre-filter code would take any tag with the name <span class="Code">PublicationInfo</span> 
        and add a <span class="Code">meta</span> attribute to it, thus telling 
        the <b><i>textIndexer</i></b> to add the publication info to the meta-data 
        index for the current document rather than the main text index. Once meta-data 
        has been recorded for a document, it can be searched by modifying the 
        <b><i>crossQuery</i></b> servlet's Query Parser Stylesheet to generate 
        meta search requests. Doing so is described in detail below in the <a href="#crossQuery_QueryParser_Prog">Query 
        Parser Programming</a> section below.
      </p>
      <p>
        <span class="Red">Note:</span> If you mark a section of text with the <span class="Code">xtf:meta</span>
        attribute, it will <u>not</u> be included in the full text index of that
        document (accessed by querying the <span class="Code">text</span> field).
        If you want a given piece of text to appear in both the meta-data and
        full-text indexes, make two copies of it, marking one with <span class="Code">xtf:meta</span>
        and not marking the other.
      </p>
      <p>Another way in which meta-data for a document can be used is as a query 
        <i><b> sort key</b></i>. Sort keys are used by the <i><b>crossQuery</b></i> 
        servlet to reorder how query matches are displayed for the user. To use 
        a meta-field as a sort key, its contents must not be tokenized. Since 
        tokenizing is turned on by default to make a meta-data field searchable, 
        the pre-filter code that processes meta-data must explicitly turn tokenizing 
        off. This is accomplished as follows:</p>
      <pre class="Sample"><b>&lt;xsl:template match="PublicationInfo"&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;xsl:attribute name="xtf:meta" select="'true'"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:tokenize" select="'no'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      <p>Like the previous example, this pre-filter code would take any tag with 
        the name <span class="Code">PublicationInfo</span> and mark it as meta-data. 
        But the addition of the line of code shown in red disables tokenizing 
        so that the meta-data can be used as a sort key by the <i> <b>crossQuery</b></i> 
        servlet.</p>
      <p>It is important to note that since meta-data must be tokenized to be 
        searchable, and it must not be tokenized to be used as a sort key, meta-based 
        searching and sorting operations are effectively mutually exclusive. If 
        you want to perform both searching and sorting on a collection of meta-data, 
        you'll need to add code to your pre-filter to produce two copies of that 
        meta-data: one copy for searching that is tokenized, and one copy for 
        sorting that is not tokenized.</p>
      <p class="Heading3">Pre-Filters and Lazy-Tree Building</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      <p>The XTF system makes use of <i><b>Lazy Tree</b></i> files to help speed 
        document retrieval and to help the <i><b>dynaXML</b></i> servlet highlight 
        search results in context. By default, lazy tree files are generated at 
        index time by the <i><b>textIndexer</b></i>. However, through the use 
        of the<span class="Code"> -nobuildlazy </span> command-line argument, 
        the <i><b>textIndexer</b></i> can be instructed to not build the lazy 
        tree files. In this case, the <i><b>dynaXML</b></i> servlet will build 
        the lazy trees files when it needs them.<br/>
      </p>
      <p>If the<span class="Code"> -nobuildlazy </span> command-line is used to 
        delay the building of lazy tree information until document retrieval, 
        it is imperative that the pre-filter specified by the<span class="Code"> 
        docSelector.xsl </span>stylesheet is the same one specified by the <i><b>dynaXML</b></i>'s<span class="Code"> 
        docReqParser.xsl </span>stylesheet. If the two stylesheets use different 
        pre-filters, the search result information generated by the <i><b>crossQuery</b></i> 
        servlet will not match the highlighting information in the lazy tree files 
        generated by the dynaXML servlet, and chaos will ensue. </p>
    </div>
    <p class="Heading2">Summary<a name="textIndexer_PreFilter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p>In closing, a few additional facts should be mentioned about the attributes 
      supported by the XTF system:</p>
    <ol>
      <li class="ListItem"> All the examples above show the <b><i>textIndexer</i></b> 
        pre-filter adding attributes to the XML representation for a document. 
        However, for native XML documents, the attributes could have simply been 
        embedded in the original source document tags. The disadvantage of doing 
        so, however, is that the attributes in every XML document would need to 
        be updated whenever indexing changes are made to the XTF system.<br/>
        <br/>
      </li>
      <li class="ListItem"> A single tag can be assigned more than one attribute. 
        For example, a tag could be assigned both a word boost and a section title 
        if desired. Note however that some combinations (like <span class="Code">sectionType</span> 
        + <span class="Code">proximitybreak</span>) are redundant and unnecessary.<br/>
        <br/>
      </li>
      <li class="ListItem"> Currently, when a <span class="Code">meta</span> attribute 
        is added to a tag, all the other XTF specific attributes are ignored (e.g., 
        <span class="Code">wordboost</span>, <span class="Code">proximitybreak</span>, 
        etc.) </li>
    </ol>
    Finally, it should be noted that the sample <span class="Code">style/textIndexer/common/preFilterCommon.xsl</span> 
    beneath the base XTF directory (i.e., <span class="Code">XTF_HOME</span>) 
    is a good starting point for creating your own customized pre-filters. </div>
  <br/>
  <!-- textIndexer --> 
  <hr/>
  <p class="Heading1">crossQuery Programming<a name="crossQuery_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  The <b><i>crossQuery</i></b> servlet previously shown in the XTF overview allows 
  users to search the document library for particular words or phrases. If we 
  look more closely at the <b><i>crossQuery</i></b> portion of the <a href="#SummaryDiagram">XTF 
  Overview Diagram</a>, we'll see something like this: <br/>
  <p align="center"> <img src="art/crossQueryDataFlow.gif" alt="crossQuery Data Flow"/><br/>
    Figure 4: Data Flow in the <b><i>crossQuery</i></b> Servlet </p>
  Once again, the basic flow of information in this diagram is left to right. 
  A document search begins with a the user specifying some text to search for 
  on a web page. The query is assembled into a URL of the form: <br/>
  <br/>
  <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/search?text=<span class="MacroCode">TextToFind</span> 
    </span> </div>
  <p><br/>
    This query URL is then passed on to the <i><b>crossQuery</b></i> servlet for 
    processing. The first thing the servlet does is translate the query URL into 
    an XML query that the <b><i>crossQuery</i></b> search engine can actually 
    understand. This translation is accomplished by the XSLT based <b>Query Parser</b> 
    (<span class="Code">queryParser.xsl</span>.) <br/>
    <br/>
    The <b><i>crossQuery</i></b> search engine then uses the XML query to look 
    for occurrences of the specified text in the document index. Any matches that 
    are found in the index are assembled into a list of XML tags, and passed on 
    to <b>Result Formatter</b> stylesheet (<span class="Code">resultFormatter.xsl</span>.) 
    The <b>Result Formatter</b> stylesheet then converts the list of matches into 
    HTML for review by the user.</p>
  <p>Thus, <i><b>XTF</b></i> allows you to configure, through stylesheets, exactly 
    how queries will be interpreted and how the results will be formatted. For 
    advanced users, there is one more level of configurability: you can actually 
    implement several independent query interfaces, each with their own <b>Query 
    Parser</b>. How does the <i><b>crossQuery</b></i> servlet decide which parser 
    to run? By calling another stylesheet you can optionally configure, the <b>Query 
    Router</b>. <span class="Red">Note that routing is an advanced feature, and 
    most first-time XTF implementors should stick with the default router and 
    focus on the <b>Query Parser</b>.</span> </p>
  <p>Here's a diagram showing the path of decision making in <i><b>crossQuery</b></i>.<br/>
  </p>
  <p align="center"> <img src="art/crossQueryDecisionTree.gif" alt="crossQuery Decision Tree"/><br/>
    Figure 5: Decision Tree of the <b><i>crossQuery</i></b> Servlet </p>
  <p>A great way to get a hands-on feel for how <i><b>crossQuery</b></i> works 
    is to use the built-in &quot;Debug Step&quot; mode. Simply add <span class="Code">&amp;debugStep=1</span> 
    to any search URL. The generated web page will let you step through the entire 
    process, with detailed explanations and real data. The first step looks like 
    this:</p>
  <p align="center"> <img src="art/SearchDebugStep.gif" alt="Search Debug Step"/><br/>
    Figure 6: Using <b><i>crossQuery</i></b>'s Debug Step Mode</p>
  <p>The remaining two subsections describe in detail how to write <b>Query Parser</b> 
    and <b>Result Formatter</b> XSLT code to carry out the necessary translations. 
  </p>
  <div class="IndentL"> 
    <p class="Heading2">Query Parser Programming<a name="crossQuery_QueryParser_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    As previously noted, the <b>Query Parser</b> is responsible for translating 
    a URL based query into an XML query that the search engine can actually understand. 
    Consider the following pseudo-query: <br/>
    <br/>
    <div class="IndentLR"> <span class="Code">Find all occurrences of "man" and 
      "war" but not "Man of War".</span> </div>
    <br/>
    What we're trying to find here is any document containing both "man" and "war", 
    but not "Man of War", which is a kind of jellyfish. In theory, the web page 
    into which the user types the search query could take a simplified English-like 
    representation of the query with the form: <br/>
    <br/>
    <div class="IndentLR"> <span class="Code">find man and war but not "Man of 
      War"</span> </div>
    <br/>
    but writing an XSLT parser to process it would be a complicated endeavor. 
    To simplify things, we'll assume that the web page has a field that accepts 
    all the words or phrases to find, and another field that accepts all the words 
    or phrases to exclude. For our specific example, the user would type <br/>
    <br/>
    <div class="IndentLR"> <span class="Code"> man war </span> </div>
    <br/>
    into the <b>text to find</b> field, and <br/>
    <br/>
    <div class="IndentLR"> <span class="Code"> "Man of War" </span> </div>
    <br/>
    into the <b>text to exclude</b> field. Note that each word or phrase is separated 
    from the others by a space, and that an exact phrase (like <span class="Code">Man 
    of War</span>) is enclosed in double-quotes to differentiate it from a list 
    of individual words. The resulting query URL that would be passed to the <b><i>crossQuery</i></b> 
    servlet would then look something like this: <br/>
    <br/>
    <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/search?text=man+war&amp;text-exclude=%22Man+of+War%22 
      </span> </div>
    <br/>
    Notice that the first part of the URL (everything before the <b>?</b> symbol) 
    invokes the <b><i>crossQuery</i></b> servlet, and second part of the URL (everything 
    after the <b>?</b> symbol) defines the search to be performed. Also notice 
    that search to be performed is represented by two parameters: <br/>
    <br/>
    <table width="90%" cellpadding="0" cellspacing="12">
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">text=man+war</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The list of 
          words search for.</span></td>
      </tr>
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">text-exclude=%22Man+of+War%22</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The phrase to 
          exclude from the search.</span></td>
      </tr>
    </table>
    <br/>
    These two parameters carry the "find" and "exclude" semantics represented 
    by the two fields of our imagined query Web-Page. As is typical for URLs, 
    the spaces in each parameter have been replaced with plus signs (<span class="Code">+</span>), 
    and the double-quote characters have been replaced with their ANSI equivalent 
    hexadecimal values. <br/>
    <br/>
    Since the <b>Query Parser</b> is written in XSLT, it actually expects an XML 
    document as its input, and not a URL like the one presented above. Consequently, 
    the <b><i>crossQuery</i></b> servlet preprocesses the query URL and turns 
    it into an XML input fragment for the <b>Query Parser</b> to translate. In 
    general, the input XML passed to the <b>Query Parser</b> looks like this: 
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="<span class="MacroCode">ParamName</span>" value="<span class="MacroCode">ParamValue</span>"&gt;
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
           â€¦
  &lt;/param&gt;
      â€¦
&lt;/parameters&gt;</b></pre>
    where <span class="MacroCode">Token</span> specifies a single word, and has 
    the form: <br/>
    <br/>
    <div class="Sample"> <span class="Code"> &lt;token value="<span class="MacroCode">Word</span>" 
      isWord = "<span class="MacroCode">YesOrNo</span>"/&gt; </span> <br/>
      <br/>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">Word</span>" 
          </td>
          <td><span class="BaseStyle">is the actual word or symbol extracted from 
            the URL.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> isWord="<span class="MacroCode">YesOrNo</span>" 
          </td>
          <td><span class="BaseStyle">identifies whether the token is a word or 
            punctuation symbol.</span></td>
        </tr>
      </table>
    </div>
    <br/>
    and <span class="MacroCode">Phrase</span> specifies an entire phrase extracted 
    as a single string, with the form: <br/>
    <br/>
    <div class="Sample"> 
      <pre class="Code">&lt;phrase value="<span class="MacroCode">StringOfWords</span>"&gt;
    <span class="MacroCode">Token</span>
       â€¦
    <span class="MacroCode">Token</span>
&lt;/phrase&gt;
</pre>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">StringOfWords</span>" 
          </td>
          <td><span class="BaseStyle">is the entire phrase extracted from the 
            URL as a single string.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> <span class="MacroCode">Token</span>...<span class="MacroCode">Token</span> 
          </td>
          <td> <span class="BaseStyle"> is the original phrase broken down into 
            individual token tags for each word or symbol in the phrase. </span> 
          </td>
        </tr>
      </table>
    </div>
    <br/>
    For our particular example URL, the input XML fragment passed to the <b>Query 
    Parser</b> would be: <br/>
    <br/>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="text" value="man war"&gt;
     &lt;token value="man" isWord="yes"/&gt;
     &lt;token value="war" isWord="yes"/&gt;
  &lt;/param&gt;

  &lt;param name="text-exclude" value="&#34;Man of War&#34;"&gt;
     &lt;phrase value="Man of War"/&gt;
         &lt;token value="Man" isWord="yes"/&gt;
         &lt;token value="of"  isWord="yes"/&gt;
         &lt;token value="War" isWord="yes"/&gt;
     &lt;/phrase&gt;
  &lt;/param&gt;

&lt;/parameters&gt;</b></pre>
    As mentioned before, it is the job of the <b>Query Parser</b> XSLT code 
    to translate the above input into an XML query that the <b><i>crossQuery</i></b> 
    search engine understands. The general format of an XML query passed to the 
    search engine has the form: <br/>
    <br/>
    <pre class="Sample"><b>&lt;query indexPath="<span class="MacroCode">LocationOfIndexDBToUse</span>" style="<span class="MacroCode">ResultFormatterLocation</span>"&gt;

    <span class="MacroCode">QueryElements</span>

&lt;/query&gt;</b></pre>
    <p>The <span class="Code">&lt;query...&gt;</span> tag is always the outermost 
      tag in a query, containing all the other tags that define the query to be 
      performed. Through its <span class="Code">indexPath="<span class="MacroCode">LocationOfIndexDBToUse</span>&quot;</span> 
      attribute, this tag identifies the Lucene index to use when performing the 
      query. Through its <span class="Code">style="<span class="MacroCode">ResultFormatterLocation</span>"</span> 
      attribute, it also defines the path to the <a href="#crossQuery_ResultFormatter_Prog">Result 
      Formatter</a> XSLT stylesheet that will format the query results. For both 
      attributes, the path specified is relative to the base install path for 
      the XTF system (i.e.,<span class="Code"> XTF_HOME</span>.) <br/>
      <br/>
      Within the <span class="Code">&lt;query...&gt;</span> tag, the <span class="MacroCode">QueryElements</span> 
      identify the type of query to perform. The simplest query that can be performed 
      is a query for a single word, or <i><b>term</b></i>. It has the form:</p>
    <pre class="Sample"><b>&lt;term field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;

    <span class="MacroCode">WordToFind</span>

&lt;/term&gt;</b></pre>
    <p>This tag indicates that we wish to find a single word in the field identified 
      by <span class="Code">field=</span>&quot;<span class="MacroCode">FieldToSearch</span>&quot; 
      . If we wish to search the main text of a document, <span class="MacroCode">FieldToSearch</span> 
      should be set to <span class="Code"><span class="Code">text</span></span>. 
      If we wish to search meta data for a document, we would use a meta-data 
      field name instead, like <span class="Code">creator</span> or <span class="Code">subject</span>. 
      Once the search field been identified, the single word we actually wish 
      to find should substituted for <span class="MacroCode">WordToFind</span>.<br/>
      <br/>
      The next simplest query to perform is a <i><b>phrase query</b></i>. It has 
      the form:</p>
    <pre class="Sample"><b>&lt;phrase field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;
    <span class="MacroCode">Term</span>
    <span class="MacroCode">Term</span>
      â€¦
&lt;/phrase&gt;</b></pre>
    <p>This query contains one or more term tags that together identify a phrase 
      to find, rather than a single word. For example, the <b>&quot;Man of War&quot;</b> 
      phrase in our sample query above would be constructed using the <span class="Code">&lt;phrase...&gt;</span> 
      and <span class="Code">&lt;term...&gt;</span> tags as follows:</p>
    <pre class="Sample"><b>&lt;phrase field=&quot;text&quot;&gt;
    &lt;term&gt; Man &lt;/term&gt;
    &lt;term&gt; of  &lt;/term&gt;
    &lt;term&gt; War &lt;/term&gt;
&lt;/phrase&gt;</b></pre>
    <p>It should be noted from this example the <span class="Code">field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;</span> 
      attribute doesn't need to be specified in each of the <span class="Code">&lt;term...&gt;</span> 
      tags, since the enclosing <span class="Code">&lt;phrase...&gt;</span> tag 
      has already identified the field to be searched.</p>
    <p>The one remaining query element that we would need to construct a complete 
      query for our man and war not &quot;Man of War&quot; example is the <i><b>query 
      clause</b></i>. It has the form: </p>
    <pre class="Sample"><b>&lt;<span class="MacroCode">ClauseType</span> field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;
    <span class="MacroCode">Term</span> | <span class="MacroCode">Clause</span>
    <span class="MacroCode">Term</span> | <span class="MacroCode">Clause</span>
         â€¦
&lt;/<span class="MacroCode">ClauseType</span>&gt;</b></pre>
    Where valid <span class="MacroCode">ClauseType</span> values are <span class="Code">and</span>, 
    <span class="Code">or</span>, <span class="Code">not</span>, <span class="Code">near</span>, 
    <span class="Code">phrase</span>, and <span class="Code">exact</span>. Each 
    of these clause types do pretty much what you would expect: 
    <ul>
      <li class="ListItem"> The <span class="Code">and</span> clause requires 
        all its sub-terms/phrases/clauses to be present for a match to occur. 
      </li>
      <li class="ListItem"> The <span class="Code">or</span> clause requires any 
        one of its sub-terms/phrases/clauses to be present for a match to occur. 
      </li>
      <li class="ListItem"> The <span class="Code">not</span> clause requires 
        that none of its sub-terms/phrases/clauses are present for a match to 
        occur. </li>
      <li class="ListItem"> The <span class="Code">near</span> clause requires 
        all its sub-terms/phrases/clauses to be <b><i>near</i></b> each other 
        for a match to occur. The definition of <b><i>near</i></b> is fairly complicated, 
        and will not be discussed here. See the <a href="tagRef.html#crossQuery_QueryParser_Tags">Query 
        Parser tag reference</a> for an in-depth description of the <span class="Code">near</span> 
        clause. </li>
      <li class="ListItem">The <span class="Code">exact</span> clause operates 
        just like the<span class="Code"> phrase </span>clause, except that it 
        matches the entire contents of a field only, whereas a<span class="Code"> 
        phrase </span>clause can match anywhere within the field. </li>
    </ul>
    Now, for the sample query we discussed above: <br/>
    <br/>
    <div class="IndentLR"> <span class="Code">man and war not "Man of War"</span> 
    </div>
    <br/>
    the complete query would look as follows: 
    <pre class="Sample"><b>&lt;query indexPath=&quot;./index&quot; style="./style/crossQuery/resultFormatter.xsl"&gt;
    &lt;and field=&quot;text&quot;&gt;
        &lt;term&gt; man &lt;/term&gt;
        &lt;term&gt; war &lt;/term&gt;
        &lt;not&gt;
            &lt;phrase&gt;
                &lt;term&gt; Man &lt;/term&gt;
                &lt;term&gt; of  &lt;/term&gt;
                &lt;term&gt; War &lt;/term&gt;
            &lt;/phrase&gt;
        &lt;/not&gt;
    &lt;/and&gt;
&lt;/query&gt;</b></pre>
    At this point, the trick is to write a <span class="Code">queryParser.xsl</span> 
    stylesheet that converts the given input XML fragment into the output XML 
    query shown above. Unfortunately, writing XSLT is well beyond the scope of 
    this document and will not be discussed here. The good news however is that 
    the sample <span class="Code">queryParser.xsl</span> included with the XTF 
    installation performs the necessary query conversion illustrated in this example, 
    and is a good starting point for creating your own custom Query Parser. <br/>
    <br/>
    It should also be noted that the various query tags illustrated here have 
    been shown in their simplest form for the sake of clarity. For example the 
    <span class="MacroCode">Query</span> tag has additional attributes that allow 
    query matches to be returned a few at a time. This allows the Result Formatter 
    to display a short page of search results rather than a single page containing 
    every result in the repository. Another thing to note is that <span class="MacroCode">Phrase</span> 
    tags are in fact recursive, and can contain sub-phrases or clauses (not just 
    <span class="MacroCode">Term</span> tags.) For a complete description of query 
    tags and the attributes they support, please refer to the <a href="tagRef.html#crossQuery_QueryParser_Tags">Query 
    Parser Tag Reference</a>. 
    <p class="Heading2">Result Formatter Programming<a name="crossQuery_ResultFormatter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p>The last stage in the <i><b>crossQuery</b></i> data flow is formatting 
      the results. Recall that the URL parameters were parsed into an XTF-compatible 
      query by the <b>Query Parser</b> stylesheet. Then the <b>Text Engine</b> 
      runs that query against indexed data, resulting in a list of matching documents. 
      The final task is to put a pretty face on things, and that's where the <b>Result 
      Formatter</b> stylesheet enters in. It transforms the XML list of documents 
      into an easy-to-use HTML result page.</p>
    <p>How does XTF know which stylesheet to use? Simple: the <b>Query Parser</b> 
      tells it. The<span class="Code"> &lt;query...&gt; </span>tag it outputs 
      specifies a<span class="Code"> style </span>attribute, which points at the 
      <b>Result Formatter</b> stylesheet that you want XTF to run. Thus, it is 
      quite possible -- and often useful -- to have multiple result formatters 
      for different purposes or display modes, and program the <b>Query Parser</b> 
      to decide which formatter to run based on a URL parameter. But we'll assume 
      for now that you only have one formatter.</p>
    <p>To accomplish its work, the <b>Result Formatter</b> receives three pieces 
      of data:</p>
    <ol>
      <li> 
        First, it receives the same<span class="Code"> 
            &lt;parameters...&gt; </span>block that was passed to the <b>Query 
            Parser</b>. This contains parsed versions of all the URL parameters, 
            in case the <b>Result Formatter</b> wants to act on these as well.
      </li>
      <li>Next, it also receives a copy of the full<span class="Code"> &lt;query&gt; 
        </span>element that was produced by the <b>Query Parser</b>.</li>
      <li>Finally and most importantly comes a list of documents that matched 
        the query. Each<span class="Code"> &lt;docHit...&gt; </span>element will 
        contain meta-data in addition to snippets of matching text from the main 
        body of each document.</li>
    </ol>
    <p>It's easy to view the XML that <b><i>crossQuery</i></b> sends to the <b>Result 
      Formatter</b>. Simply append<span class="Code"> &amp;raw=1 </span>to the 
      URL, and the servlet will bypass the formatter completely and display the 
      raw XML directly in your browser. A great way to plan your stylesheet is 
      to run some sample queries and look at the raw XML, then try to envision 
      how you want it to look in HTML.</p>
    <p>Here's a real-life sample of <b>Result Formatter</b> input, coming from 
      a query for the words &quot;man&quot; and &quot;war&quot;. Much of the repetitive 
      information has been snipped out so you can get a quick idea of the structure 
      without getting bogged down in details.</p>
    <pre class="Sample">&lt;<b>crossQueryResult</b> queryTime=&quot;0.32&quot; totalDocs="8" startDoc="1" endDoc="8">

  &lt;<b>parameters</b>>
    &lt;param name="text" value="man war">
       &lt;token value="man" isWord="yes"/>
       &lt;token value="war" isWord="yes"/>
    &lt;/param>
    <span class="MacroCode">...additional URL parameters here...</span>
  &lt;/<b>parameters</b>>

  &lt;<b>query</b> indexPath="index" termLimit="1000" workLimit="1000000"
         style="style/crossQuery/resultFormatter/default/resultFormatter.xsl"
         startDoc="1" maxDocs="10">
     &lt;and field="text" maxSnippets="3" maxContext="100">
       &lt;term>man&lt;/term>
       &lt;term>war&lt;/term>
     &lt;/and>
  &lt;/<b>query</b>>
  
  &lt;<b>docHit</b> rank="1" path="default:r1/ft2s2004r1/ft2s2004r1.xml" score="100" totalHits="3">
    &lt;meta>
       &lt;title>Asylia: Territorial Inviolability in the Hellenistic World&lt;/title>
       &lt;creator>Kent J. Rigsby&lt;/creator>
       <span class="MacroCode">...more meta-data here...</span>
    &lt;/meta>
    &lt;snippet rank="1" score="100">inspoliatus : [Sall. ] Resp . 1.2.7, in the civil &lt;hit>
          &lt;term>war&lt;/term> 
          &lt;term>men&lt;/term>
       &lt;/hit> fled to Pompey "as debtors use a sacred&lt;/snippet>
    &lt;snippet rank="2" score="53">he explains, will win the favor of gods and &lt;hit>
          &lt;term>men&lt;/term>, and just &lt;term>wars&lt;/term>
       &lt;/hit> are defensive. The locus classicus is&lt;/snippet>
    &lt;snippet rank="3" score="53">the Roman peace, which ended the state of &lt;hit>
          &lt;term>war&lt;/term> among &lt;term>men&lt;/term>
       &lt;/hit>). More generally, legend told of various&lt;/snippet>
  &lt;/<b>docHit</b>>

  &lt;<b>docHit</b> rank="2" path="default:7d/ft7w10087d/ft7w10087d.xml" score="76" totalHits="6">
    &lt;meta>  <span class="MacroCode">...meta-data here...</span> &lt;/meta>
    &lt;snippet rank="1" score="100">the mother of shields." Kunu refers to the &lt;hit>
          &lt;term>war&lt;/term> shields &lt;term>men&lt;/term>
       &lt;/hit> used to fashion from lighter bark, some&lt;/snippet>
    <span class="MacroCode">...more snippets here...</span>
  &lt;/<b>docHit</b>>

  &lt;<b>docHit</b> rank="3" path="default:pf/ft7r29p1pf/ft7r29p1pf.xml" score="76" totalHits="2">
    <span class="MacroCode">...meta-data and snippets here...</span>
  &lt;/<b>docHit</b>>

  <span class="MacroCode">...additional document hits here...</span>
&lt;/<b>crossQueryResult</b>></pre>
    <p>Essentially, each matching document will have a corresponding<span class="Code"> 
      &lt;docHit&gt; </span>tag, and these will be sorted in some order, generally 
      by descending score (relevance). Each document hit contains corresponding 
      meta-data within a<span class="Code"> &lt;meta&gt; </span>sub-tag. Hits 
      on the full text of the document will have<span class="Code"> &lt;snippet&gt; 
      </span>tags, each with its own<span class="Code"> &lt;hit&gt; </span>tag 
      inside it.</p>
    <p>A little more formally, the result formatter receives a<span class="Code"> 
      &lt;crossQueryResult&gt; </span>tag that looks like this: </p>
    <pre class="Sample"><b>&lt;crossQueryResult queryTime = "<span class="MacroCode">TimeInSeconds</span>" 
                  totalDocs = "<span class="MacroCode">NumberOfDocs</span>" 
                  startDoc  = "<span class="MacroCode">FirstDocNumber</span>" 
                  endDoc    = "<span class="MacroCode">LastDocNumber</span>"&gt;
    <span class="MacroCode">Parameters
</span>    <span class="MacroCode">Query
</span>
    <span class="MacroCode">DocumentHit</span>
    <span class="MacroCode">DocumentHit</span>
        â€¦
&lt;/crossQueryResult&gt;</b></pre>
    <p>Note that, depending on the query and the size of the document repository, 
      there might be thousands of matching documents, and this thousands of<span class="Code"> 
      &lt;docHit&gt; </span>tags. Suppose you only wanted to display the first 
      page of hits, say ten of them? It would be simple to make a <b>Result Formatter</b> 
      that simply picked the first 10 and ignored the rest, but that would be 
      very inefficient because the XSLT processor will still have to parse and 
      process <i>all</i> of the document hits. A much more efficient way to handle 
      paging is to modify the <b>Query Parser</b> to specify<span class="Code"> 
      maxDocs=&quot;10&quot; </span>in the<span class="Code"> &lt;query&gt; </span>element; 
      then only the first ten document hits will be passed to the <b>Result Formatter</b> 
      and the user interface will be much more responsive.</p>
    <p>Each Document Hit looks like this: </p>
    <pre class="Sample"><b>&lt;docHit rank="<span class="MacroCode">DocRelevanceRank</span>" path="<span class="MacroCode">DocumentLocation</span>" score="<span class="MacroCode">DocRelevanceScore</span>"&gt;
  &lt;meta&gt;
    <span class="MacroCode">Meta-data defined by index Pre-Filter stylesheet</span>
  &lt;/meta&gt;

  <span class="MacroCode">Snippet</span>
  <span class="MacroCode">Snippet</span>
    â€¦
&lt;/docHit&gt;</b></pre>
    <p>The meta-data is copied directly from the tags in the input document marked 
      by the index Pre-Filter stylesheet using the<span class="Code"> xtf:meta=&quot;yes&quot; 
      </span>attribute. If the query targets meta-data fields, these may have<span class="Code"> 
      &lt;snippet&gt; </span>and/or<span class="Code"> &lt;hit&gt; </span>tags 
      embedded within them, marking the exact location of the matching terms. 
    </p>
    <p>If the query targets the &quot;text&quot; field -- that is, the full document 
      text -- then the<span class="Code"> &lt;docHit&gt; </span>tag will have 
      one or more<span class="Code"> &lt;snippet&gt; </span>tags containing the 
      matching text and some surrounding context:</p>
    <pre class="Sample"><b>&lt;snippet rank="<span class="MacroCode">MatchRelevanceRank</span>" score="<span class="MacroCode">MatchRelevanceScore</span>"&gt;

    <span class="MacroCode">Hit Text (and context text, if any)</span>

&lt;/snippet&gt;</b></pre>
    <p>Within each snippet will appear a<span class="Code"> &lt;hit&gt; </span>tag 
      with one or more<span class="Code"> &lt;term&gt; </span>tags marking the 
      exact matching terms.</p>
    <p>The bulk of the Result Formatter's work will be in transforming all these<span class="Code"> 
      &lt;docHit&gt;</span>,<span class="Code"> &lt;meta&gt;</span>,<span class="Code"> 
      &lt;snippet&gt;</span>, <span class="Code"> &lt;hit&gt;</span>, and<span class="Code"> 
      &lt;term&gt; </span>XML tags into meaningful HTML output. Writing XSLT is 
      beyond the scope of this document, but a good way to learn is to begin modifying 
      the sample <b>Result Formatter</b> stylesheet. The stylesheet is included 
      with the XTF distribution in the<span class="Code"> style/crossQuery/resultFormatter 
      </span>directory. </p>
    <p>It should also be noted that the various input tags have bells and whistles 
      not mentioned in this short tutorial. For a full specification, please refer 
      to the <a href="tagRef.html#crossQuery_ResultFormatter_Tags">Result 
      Formatter Tag Reference</a>.<br/>
    </p>
    
  <p class="Heading1">Spelling Correction<a name="Spelling"></a></p>
  <!-- - - - - - - - - - - - - - --> 
  <p>
    Users often misspell words when they're querying an XTF index, and it
    would be nice if the system could catch the most obvious errors and
    automatically suggest an appropriate spelling correction. XTF provides
    a facility for easily achieving this "Did you mean...?" functionality.
  </p>
  <p>
    The following sections discuss how to add a spelling
    dictionary at index time, conditionally activate spelling correction at query
    time, and how the resulting suggestions make it to the result formatter.
    If you're interested in the details of the algorithm or
    data structures used, please see 
    <a href="underHood.html#Spelling">XTF Under the Hood</a>.
  </p>
  <div class="IndentL"> 
    <!-- - - - - - - - - - - - - - --> 
    <p class="Heading2">Creating a Spelling Correction Dictionary<a name="Spelling_Dict"></a></p>
    <p>
      Before spelling correction can be activated in <span class="Keyword">crossQuery</span>,
      XTF needs a specially calculated spelling correction dictionary. This dictionary is
      calculated at the time the XTF index is created, and is based on the words found
      in the indexed documents (rather than on a standard word dictionary.) The advantage of
      this dynamic process is that proper names and foreign words that wouldn't appear in
      a standard dictionary can and will be included in the XTF spelling dictionary.
    </p>
    <p>
      To turn on spelling dictionary generation, it must be enabled in the
      <span class="Keyword">textIndexer</span> configuration file:
      <span class="Code">conf/textIndexer.conf</span>. Simply add a tag like this:
    </p>
    <p class="Sample">
      Â <span class="Code">&lt;spellcheck createDict="yes"></span>
    </p>
    Now when the indexer runs, it will accumulate words from the document text, and at
    the end of the indexing run it will generate the spelling correction dictionary.
    Note that dictionary generation is quite fast, generally a small fraction of the
    overall indexing time and disk space, so it usually makes sense to leave spelling correction
    enabled (it is by default.)
  </div>
    
  <!-- - - - - - - - - - - - - - --> 
  <!-- Activating spell-check --> 
  <div class="IndentL"> 
    <!-- - - - - - - - - - - - - - --> 
    <p class="Heading2">Activating Spelling Correction<a name="Spelling_Activation"></a></p>
      <p>
        To turn on spelling correction in <span class="Keyword">crossQuery</span>,
        modify the <b>Query Parser</b> stylesheet to add a new element just under
        the top-level <span class="Code">&lt;query></span> tag:
      </p>
      <p class="Sample">
        <span class="Code">&lt;spellcheck/></span>
      </p>
      <p>
        This requests that the servlet use its default parameters to decide 
        when a query is probably misspelled (i.e. 10 or fewer document hits),
        which terms in a user's query are probably misspelled, and the best
        suggestions for those terms. If you wish to exert finer control over
        the process, see the 
        <a href="tagRef.html#crossQuery_QueryParser_Output_Spellcheck">Spelling Correction Tag</a> 
        reference for details.
      </p>
      <p>
        If the documents that result from a query are of insufficient quantity
        or score (controlled by attributes above), the <b>Text Engine</b> will
        check each query term for possible spelling correction. If any corrections
        are found, they're ranked for "best fit" and the best suggestion
        sent to the Result Formatter (see below).
      </p>
    </div>
    <div class="IndentL"> 
      <!-- - - - - - - - - - - - - - --> 
      <p class="Heading2">Formatting the Suggestions<a name="Spelling_Formatting"></a></p>
      <p>
        Spelling corrections appear in the results under a special 
        <a href="tagRef.html#crossQuery_ResultFormatter_Spelling">Spelling Result</a>
        tag, with one 
        <a href="tagRef.html#crossQuery_ResultFormatter_SpellingSuggestion">Spelling Suggestion</a> 
        tag per misspelled word in the original query.
        The <b>Result Formatter</b> stylesheet needs to recognize
        these tags and display
        the suggestions in the final HTML result sent to the user's browser.
      </p>
      <p>
        For example, if the user queried for 
        <span class="Code">who kiled harrypotter</span> (and your index documents have
        something to do with Mr. Potter), then crossQuery might send the following to
        your Result Formatter:
      </p>
      <pre class="Sample">&lt;spelling&gt;
  &lt;suggestion origTerm="kiled" suggestedTerm="killed"&gt; 
  &lt;suggestion origTerm="harrypotter" suggestedTerm="harry potter"&gt; 
&lt;/spelling&gt;</pre>
      <p>
        Your job then is to take these suggestions, display them to the user, and
        give them a link that implements the changed query. The default stylesheets
        that come with the XTF distribution do this, but if you have customized
        the query parsing and result formatting, you may need to modify this
        XSLT code to match your customizations.
      </p>
    </div>

    <p class="Heading2">Faceted Browsing<a name="Faceted_Browsing"></a></p>
    <!-- - - - - - - - - - - - - - --> 
    <p><b><i>crossQuery</i></b> provides a good general-purpose solution for searching 
      a large collection of documents. However, we haven't up to this point covered
      any convenient 
      or useful way to <i>browse</i> such a collection. In other words, a user will
      have a difficult time if they're not quite sure what subject they're looking for, 
      or if they just want to get an idea of what is offered by the collection.</p>
    <p>There are many possible ways to build a browsing system, but one very promising
      avenue is called <i>faceted browsing</i>, a way of intuitively exploring 
      a collection that has rich meta-data. If one thinks of the collection as a bag 
      of jewels, each meta-data field is a &quot;facet&quot;, and items will have 
      various values for that facet. The user can choose to explore one or many facets 
      simultaneously.</p>
    <p class="Note">
      Note: Faceted browsing is an advanced and fairly complex
      topic. Those new to XTF would be advised to skip this section for now,
      and get a robust system working in XTF before attempting a faceted browse
      system. Additionally, the feature is new enough that the default stylesheets
      in XTF do not yet implement faceted browse, so there is no example code
      you can work with; we plan to add this at some point in the future.
    </p>
    <p>A good example of a faceted browse system was developed by Prof. Marti Hearst 
      at UC Berkeley. The system is called Flamenco, and the 
      <a href="http://bailando.sims.berkeley.edu/flamenco.html">Flamenco web 
      site</a> is quite informative and includes a good demonstration. For more information 
      the reader is encouraged to play with and read about Flamenco.</p>
    <p>XTF's faceted browse feature is built in to the <b><i>crossQuery</i></b> 
      servlet. One might ask whether it should have been a separate servlet altogether, 
      but there is a good reason to have search and browse in the same servlet: it 
      can be quite useful to combine the two activities. For instance, a user might 
      enter a search for &quot;africa&quot;, and then use the browse system to get 
      an idea of the collection's coverage, in terms of dates (the interface might 
      include decades and a count of documents for each one), subjects, authors, etc.</p>
    <div class="IndentL"> 
      <p class="Heading3">Meta-data Requirements<a name="Faceted_MetaReq"></a></p>
      <!-- - - - - - - - - - - - - - --> 
      <p>The faceted browse system relies on properly marked meta-data in the documents. 
        Essentially, it relies on meta-data fields that are not tokenized during the 
        indexing process. If you are creating meta-data fields for sorting, you already 
        know how to do this.</p>
      <p>There are two ways to create a non-tokenized field. Both involve using the 
        pre-filter stylesheet used by the <i> <b>textIndexer</b></i> to add an additional 
        attribute to an element (the element should already be marked with <span class="Code">xtf:meta=&quot;yes&quot;</span>.)</p>
      <ol>
        <li> Add <span class="Code">xtf:tokenize=&quot;no&quot;</span> to the meta-data 
          element. This will keep the indexer from tokenizing the field (and therefore, 
          the user cannot perform queries on it.) But the contents will still be available 
          to the result formatter for display. <br/>
          <br/>
          <i>... or ...</i><br/>
          <br/>
        </li>
        <li>Add <span class="Code">xtf:indexOnly=&quot;yes&quot;</span> to the meta-data 
          element. Again the indexer won't tokenize the field, but it also won't store 
          the contents of the field. This is more efficient if you don't need to display 
          the contents in the result formatter.</li>
      </ol>
      <p>What if you want to be able to search within a field <i>and</i> also use 
        it for browsing? Simply program your pre-filter to make two copies of the meta-data 
        field, one tokenized and one untokenized. Of course you should give them distinct 
        names so you can tell them apart later. For example, one might create a &quot;subject&quot; 
        field (tokenized) and a &quot;facet-subject&quot; field (untokenized) both 
        of which contain the same data. In this case, it's wise to make the non-tokenized 
        one <span class="Code">indexOnly</span>, to avoid storing the same data twice.</p>
      <p>See the <a href="#textIndexer_PreFilter_Prog">pre-filter 
        programming</a> section of this guide for more information. 
        <br/>
      </p>
    </div>

    <div class="IndentL"> 
      <p class="Heading3">Adding Facets to the Stylesheets<a name="Faceted_Query"></a></p>
      <!-- - - - - - - - - - - - - - --> 
      <p>The first step to implementing a browse system is to add facets to the <b>Query 
        Parser </b>stylesheet. You can add one or more<span class="Code"> &lt;facet&gt; 
        </span>elements as top-level children of the<span class="Code"> &lt;query<span class="BaseStyle">...</span>&gt; 
        </span>element. For a fuller description see the
        <a href="tagRef.html#crossQuery_QueryParser_Output_Facet">Facet Tag</a>
        in the <b>XTF Tag Reference</b>.
        Modify your query parser to add a<span class="Code"> &lt;facet&gt; </span>tag 
        for each meta-data field you want to browse by in the user interface. </p>
      <p>Here are a couple other things to note when constructing your query parser:</p>
      <ol>
        <li> The document hits accumulated for selected groups in a facet tag are 
          independent of those for the main query. If you want both, fine. If you 
          <i>only</i> want facet counts, or want document hits <i>only </i>accumulated 
          within the facet, then specify<span class="Code"> maxDocs=&quot;0&quot; 
          </span>on your main<span class="Code"> &lt;query<span class="BaseStyle">...</span>&gt; 
          </span>element. <br/>
          <br/>
        </li>
        <li>For purposes of facets, XTF counts only those documents matched by the 
          main query. Thus, you can use a query to form arbitrary slices of a repository, 
          and the facet system will report information about each slice.<br/>
          <br/>
        </li>
        <li>In the case where you want to count <i>all</i> the documents in the repository, 
          you need to make a query that <i>matches</i> all documents. A simple way 
          to do this is to specify a<span class="Code"> &lt;not&gt; </span>query on 
          a term that doesn't exist, like this:<br/>
          <pre class="Code">&lt;query<span class="MacroCode"> ...</span>>
    &lt;facet field="field1" <span class="MacroCode">...</span>/>
    &lt;facet field="field2" <span class="MacroCode">...</span>/>
    â€¦
    &lt;not field="field1">
        &lt;term>veryUnlikelyTerm&lt;/term>
    &lt;/not>
&lt;/query></pre>
        </li>
      </ol>
      Now that we've covered how to construct a<span class="Code"> &lt;facet<span class="BaseStyle">...</span>&gt; 
      </span>element, it's time to look at the results.
      In the case of a faceted query, the normal query results passed to the <b>Result 
      Formatter</b> stylesheet are supplemented with one or more <a href="tagRef.html#crossQuery_ResultFormatter_Facet">Facet Result Tags</a>, 
      one per facet in the input query. These appear at the top level of the input 
      to the <b>Result Formatter</b>, that is, as children of the<span class="Code"> 
      &lt;crossQueryResult&gt; </span>element.<br/>

    </div>
    
    <div class="IndentL"> 
      <p class="Heading3">Group Selection<a name="Facet_Group_Selection"></a></p>
      <!-- - - - - - - - - - - - - - --> 
      <p>A faceted query may result in a very large number of groups. For instance, 
        a very large collection of documents could have thousands of different Subject 
        headings; if one were browsing by subject it would be silly to look at a page 
        containing a thousand subjects. So some intelligence is needed in picking 
        which subjects to show. In addition, some applications will want to display 
        document hits below the first group, or the first four groups, etc. </p>
      <p>XTF provides a fairly sophisticated mechanism for choosing which groups to 
        return, and to control the groups that will have documents hits gathered for 
        them. The group selection mechanism is somewhat loosely modeled on XPath. 
        Since XTF's group selection language is under considerable development, this 
        section simply teaches by example rather than providing a formal specification.</p>
      <p>We will refer to the following 10 groups in the discussion to follow:</p>
      <div class="IndentL"> 
        <table width="90%" border="0">
          <tr> 
            <td width="86%" class="Code">African Studies</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Ancient History</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">California and the West</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Classical Religions</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Classics</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Environmental Studies</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Philosophy</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Politics</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Social Theory</td>
          </tr>
          <tr> 
            <td width="86%" class="Code">Sociology</td>
          </tr>
        </table>
      </div>
      <br/>
      <p>Let's start with the simplest possible selection expression:</p>
      <div class="Sample"><span class="Code">select=&quot;*&quot;</span></div>
      <p>Essentially, &quot;<span class="Code">*</span>&quot; is a wildcard that matches 
        any group, regardless of its name. This is the simplest possible selection 
        expression; it simply selects all groups --<span class="Code"> African Studies 
        </span>through<span class="Code"> Sociology </span>-- and returns them. (Well, 
        it selects all top-level groups in the case of a hierarchical field; see <a href="#Facet_Hierarchical">Hierarchical 
          Facets</a> later on.) This is the default behavior if the<span class="Code"> 
            select </span>attribute is not specified for a facet. </p>
      <p>It's important to note that by default XTF skips over groups that have no 
        hits. If you really want all the groups including empty ones, specify the<span class="Code"> 
          includeEmptyGroups </span>attribute in the<span class="Code"> &lt;facet<span class="BaseStyle">...</span>&gt; 
          </span>query tag.</p>
      <div class="Sample"><span class="Code">select=&quot;*[1-5]&quot;</span></div>
      <p>This selects the first five groups,<span class="Code"> African Studies </span>through<span class="Code"> 
        Classics</span>. It can be interpreted this way: &quot;Start with all groups, 
        regardless of name. From that set, select items 1 through 5.&quot;</p>
      <p>It is important to note that the order of the groups is very important to 
        this selection. After all the counting is performed, XTF sorts all the groups, 
        either by total number of documents (the default), or by group value/name. 
        So this selection is the first five groups, after all groups are sorted.</p>
      <p>This sort of selection is generally used for dividing the groups up into 
        pages of a fixed size (five groups per page in this case.) To get the second 
        page (<span class="Code">Environmental Studies </span>through<span class="Code"> 
          Sociology</span>), one could select &quot;<span class="Code">*[6-10]</span>&quot;, 
        etc.</p>
      <div class="Sample"><span class="Code">select=&quot;Ancient History&quot;</span></div>
      <p>This selection chooses a group by name,<span class="Code"> Ancient History 
      </span>in this case. This could be useful if you wanted the count for only 
        one group.</p>
      <p>Note that name selection is not case-sensitive (i.e. differences between 
        upper and lower case are ignored.)</p>
      <div class="Sample"><span class="Code">Select=&quot;Ancient History#1-4&quot;</span></div>
      <p>Here we've introduced something new. This still selects a single group, but 
        also tells XTF to gather document hits for the<span class="Code"> Ancient 
          History </span>group, and return the first four document hits.</p>
      <div class="Sample"><span class="Code">Select=&quot;Ancient History#all&quot;</span></div>
      <p>Just like above, but selects <i>all</i> documents hits (instead of just four.)</p>
      <div class="Sample"><span class="Code">Select=&quot;*[1-5]|Ancient History#1-4&quot;</span></div>
      <p>This may look complicated, but you've seen everything here before except 
        the &quot;<span class="Code">|</span>&quot; separator. All this does is perform 
        a logical union of two selections. In this case, it selects the first 5 groups 
        (<span class="Code">*[1-5]</span>). Then it also selects the<span class="Code"> 
          Ancient History </span>group, and gathers the first four document hits for 
        it (<span class="Code">Ancient History#1-4</span>)</p>
      <p>Why would you want to do this? Say for instance you wanted to display the 
        first page of groups, and you knew<span class="Code"> Ancient History </span>was 
        on that page, and you wanted document hits for that group shown. This selection 
        would accomplish exactly that. </p>
      <p>But what if you wanted to display document hits for the first group on the 
        page, and you didn't already know what that group was?</p>
      <div class="Sample"><span class="Code">select=&quot;*[1-5]|*[1]#1-4&quot;</span></div>
      <p>This selects the first five groups (<span class="Code">*[1-5]</span>) --<span class="Code"> 
        African Studies </span>through<span class="Code"> Classics</span>. Also, it 
        selects the first group (<span class="Code">*[1]</span>), which is<span class="Code"> 
          African Studies </span>in this case, and gathers four document hits for it.</p>
      <p>What if you want to select a certain group by name, and also select the other 
        groups in the same page, but you don't know in advance which page the group 
        is on? Well...</p>
      <div class="Sample"><span class="Code">select=&quot;Politics[page(size=5)]&quot;</span></div>
      <p>This expression selects the<span class="Code"> Politics </span>group, and 
        then expands to select all the other groups on the same page as<span class="Code"> 
          Politics</span>, performing calculations assuming each page is five groups.</p>
      <p>In the case of our sample data above, the first page of five groups is<span class="Code"> 
        African Studies </span>through<span class="Code"> Classics</span>. But the 
        first page doesn't contain<span class="Code"> Politics</span>, so we skip 
        it and select the groups on the second page instead --<span class="Code"> 
          Environmental Studies </span>through<span class="Code"> Sociology </span>-- 
        which does include<span class="Code"> Politics</span>.<br/>
        <br/>
      </p>
    </div>
    
    <div class="IndentL"> 
      <p class="Heading3">Hierarchical Facets<a name="Facet_Hierarchical"></a></p>
      <!-- - - - - - - - - - - - - - --> 
      <p>Above we covered one way to deal with a large number of groups, by paging 
        them. Another way is to apply structure to the groups, forming a hierarchy 
        of parent/child relationships. One obvious application is for geographical 
        information, which breaks down naturally into large groupings by nation, followed 
        by states/provinces within each nation, counties or districts within the states, 
        and thence to cities.</p>
      <p>Telling XTF about hierarchical data is simple: place the data items in a 
        meta-data field, listing the groupings from most general to most specific 
        and separating them by double-colons, like this: &quot;<span class="Code">US::California</span>&quot;. 
        In this section we'll refer to the following sample data.</p>
      <table width="90%" border="0" class="IndentL">
        <tr bgcolor="#E0E0E0"> 
          <td width="86%" class="Code"><i>Canada</i></td>
        </tr>
        <tr  bgcolor="#E0E0E0"> 
          <td width="86%" class="Code"><i>Canada::Ontario</i></td>
        </tr>
        <tr> 
          <td width="86%" class="Code">Canada::Ontario::Toronto</td>
        </tr>
        <tr bgcolor="#E0E0E0"> 
          <td width="86%" class="Code"><i>US</i></td>
        </tr>
        <tr bgcolor="#E0E0E0"> 
          <td width="86%" class="Code"><i>US::California</i></td>
        </tr>
        <tr> 
          <td width="86%" class="Code">US::California::Berkeley</td>
        </tr>
        <tr> 
          <td width="86%" class="Code">US::California::San Francisco</td>
        </tr>
        <tr> 
          <td width="86%" class="Code">US::California::Yreka</td>
        </tr>
        <tr bgcolor="#E0E0E0"> 
          <td width="86%" class="Code"><i>US::Nevada</i></td>
        </tr>
        <tr> 
          <td width="86%" class="Code">US::Nevada::Las Vegas</td>
        </tr>
        <tr> 
          <td width="86%" class="Code">US::Nevada::Reno</td>
        </tr>
      </table>
      <p>As you can see, the sample hierarchy has three levels (Nation, State/Province, 
        and City), but XTF imposes no particular limits on the depth of the hierarchy.</p>
      <p>The groups above shown with a gray background are implied by the other groups 
        but need not be present in the document repository. For example, if XTF encounters 
        the group<span class="Code"> US::Nevada::Las Vegas</span>, it automatically 
        creates the groups<span class="Code"> US::Nevada </span>and<span class="Code"> 
          US</span>, even if they those values are not specifically present in any document's 
        meta-data.</p>
      <p>Now let's consider how the group selection mechanism works in the presence 
        of hierarchical groups.</p>
      <div class="Sample"><span class="Code">Select=&quot;*&quot;</span></div>
      <p>One might think this selects all the groups, but instead it only selects 
        the <i>top-level</i> groups. In this case, it will select<span class="Code"> 
          US </span>and<span class="Code"> Canada</span>. You might ask what happens 
        if you request document hits:</p>
      <div class="Sample"><span class="Code">select=&quot;*#all&quot;</span></div>
      <p>This expression selects all top-level groups, and gathers all the document 
        hits for each group. Note that XTF will automatically count and gather document 
        hits for all the children and grandchildren of<span class="Code"> US </span>and<span class="Code"> 
          Canada</span>. That is, the<span class="Code"> US </span>group will contain 
        document hits for<span class="Code"> US::California::Berkeley</span>,<span class="Code"> 
          US::California::San Francisco</span>,<span class="Code"> US::Nevada::Reno</span>, 
        etc.</p>
      <div class="Sample"><span class="Code">select=&quot;US::*&quot;</span></div>
      <p>Selects all groups that are children of<span class="Code"> US </span>which 
        are<span class="Code"> California </span>and<span class="Code"> Nevada</span>. 
        Because no &quot;<span class="Code">#</span>&quot; is present, this expression 
        only counts documents but doesn't collect them.</p>
      <p>Note that when XTF reports the groups in <a href="tagRef.html#crossQuery_ResultFormatter_Group">Group 
        Result Tags</a>, the tags will be nested in a hierarchy which includes all 
        the necessary parents and grandparents even if they weren't specifically selected:</p>
      <pre class="Sample"><b>&lt;facet totalGroups=&quot;1&quot;<span class="BaseStyle"> ...</span>&gt;
    &lt;group value=&quot;US&quot; totalSubGroups=&quot;2&quot;<span class="BaseStyle"> ...</span>&gt;
        &lt;group value=&quot;California&quot; totalSubGroups=&quot;0&quot;<span class="BaseStyle"> ...</span>/&gt;
        &lt;group value=&quot;Nevada&quot; totalSubGroups=&quot;0&quot;<span class="BaseStyle"> ...</span>/&gt;
    &lt;/group&gt;
&lt;/facet&gt;</b></pre>
      <p>Also note that the group values do not have the colons &quot;<span class="Code">::</span>&quot; 
        embedded in them. These are only present in the document meta-data.</p>
      <p>But what if you wanted to select absolutely all of the groups, not just the 
        top-level ones? One could use a really clunky expression like &quot;<span class="Code">*|*::*|*::*::*</span>&quot;, 
        but here's an easier way:</p>
      <div class="Sample"><span class="Code">select=&quot;**&quot;</span></div>
      <p>This special syntax simply selects all the groups regardless of their level 
        in the hierarchy. This can be useful for small hierarchies, or to bypass XTF's 
        group selection mechanism and do group selection entirely in the <b>Result 
          Formatter</b> stylesheet. Note however that it can be slow when processing 
        large hierarchies.</p>
      <div class="Sample"></div>
      <p>What if you don't know which level of the hierarchy to select?</p>
      <div class="Sample"><span class="Code">select=&quot;**[topChoices]&quot;</span></div>
      <p>This instructs XTF to make a good guess as to which level of the hierarchy 
        to return, based on the documents selected by the main query. Essentially, 
        it looks for the topmost level in the hierarchy that has more than one choice.</p>
      <p>For instance, if the query produced two documents, one coded with<span class="Code"> 
        US::California::Berkeley </span>in its meta-data, and the other encoded with<span class="Code"> 
          US::Nevada::Reno</span>, then<span class="Code"> **[topChoices] </span>would 
        select<span class="Code"> California </span>and<span class="Code"> Nevada</span>. 
        Starting from the top, there's only one choice:<span class="Code"> US</span>. 
        After that, there are two choices, so XTF stops there.</p>
      <p>If instead the two documents were coded for<span class="Code"> US::California::Berkeley 
      </span>and<span class="Code"> US::California::Yreka</span>, then XTF would 
        select<span class="Code"> Berkeley </span>and<span class="Code"> Yreka</span>. 
        Again starting from the top, there's one choice:<span class="Code"> US</span>. 
        Below that, there's again one choice:<span class="Code"> California</span>. 
        Below that are two choices, so it stops there.</p>
      <p>If all the documents were for<span class="Code"> US::California::Berkeley</span>, 
        XTF would simply select that single group.</p>
    </div>
    
    <p class="Heading2">Other Common Tasks<a name="crossQuery_Common_Prog"></a></p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      
    <p>A fully fleshed-out <b><i>crossQuery</i></b> system will need to handle errors 
      gracefully. You may also wish to add session state features (to record data 
      that persists across page views.) Since these tasks are common to both servlets, 
      they are documented in the <a href="#Common_Prog">Common <i><b>crossQuery/dynaXML</b></i> 
      Programming Tasks</a> section below. </p>
    <p><!-- crossQuery --> </p>
  </div>
    
  <hr/>
  <p class="Heading1">dynaXML Programming<a name="dynaXML_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p>The <b><i>dynaXML</i></b> servlet is in charge of displaying a single XML 
    document, often in small chunks or pages, one page at a time. It forms part 
    of a complete search and display system: the user can search a collection 
    of documents using <b><i>crossQuery</i></b>, and when they find a document 
    of interest, they can explore the contents of that document using <b><i>dynaXML</i></b>. 
    If we look more closely at the dynaXML portion of the <a href="#SummaryDiagram">XTF 
    Overview Diagram</a>, we see something like this: <br/>
  </p>
  <p align="center"> <img src="art/dynaXMLDataFlow.gif" alt="dynaXML Data Flow"/><br/>
    Figure 7: Data Flow in the <b><i>dynaXML </i></b> Servlet </p>
  <p>Data flow in this diagram is from left to right. First, the user specifies 
    a document to view by sending a URL that looks like this (in its simplest 
    form):<br/>
  </p>
  <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/view?docId=<span class="MacroCode">DocumentToView</span> 
    </span> </div>
  <p>The <i><b>dynaXML </b></i>servlet breaks up the URL parameters and formats 
    them in XML. This is passed to the <b>Document Request Parser</b> stylesheet, 
    which figures out where to find the specified document and decides which stylesheet 
    will be used for formatting the result page. Also, if a search query is included 
    in the URL, the parser transforms the query into structured XML that the <b>Text 
    Engine </b>can understand.</p>
  <p>Optionally, the parser can also specify authentication to perform, allowing 
    the system to secure access to sensitive or protected documents. XTF's user 
    authentication engine checks the user's credentials using the specified authentication 
    method. </p>
  <p>Next, the servlet fetches the source XML document. If a search query was 
    specified, it uses the <b>Text Engine</b> to search for occurrences of the 
    specified text, and then inserts hit tags and snippets in their proper context 
    within the original document. </p>
  <p>Finally, the (possibly marked up) document is passed to the <b>Document Formatter</b> 
    stylesheet, which creates the final HTML page to display in the user's browser.</p>
  <p>Thus, XTF allows you to configure, again through the use of stylesheets, 
    where documents will be stored, how they can be queried, and precisely how 
    they will be displayed to the user. How are all these decisions made? This 
    diagram should clarify the chain of logic:</p>
  <p align="center"> <img src="art/dynaXMLDecisionTree.gif" alt="dynaXML Decision Tree"/><br/>
    Figure 8: Decision Tree of the <b><i>dynaXML </i></b> Servlet </p>
<p>The following sections cover the basics of programming stylesheets to drive 
    <i><b>dynaXML</b></i>.</p>
  <div class="IndentL"> 
    <p class="Heading2">Document Request Parser Programming<a name="dynaXML_DocReqParser_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p>As discussed above, the <b>Document Request Parser</b> is responsible for 
      interpreting a URL based query. XTF allows great flexibility in terms of 
      how URLs are constructed and interpreted, and this stylesheet is the key 
      to that flexibility.</p>
    <p>The main tasks of the Document Request Parser are:</p>
    <ol>
      <li>Use the URL parameters to determine which document to display, and figure 
        out exactly where to find it. Typically it will come up with a full path 
        to an XML file in the filesystem, but it can also come from an external 
        HTTP source.<br/>
        <br/>
      </li>
      <li>Decide which <b>Document Formatter</b> stylesheet to use. Many systems 
        will have only one Document Formatter, but one can set up a more complex 
        system where different formatters are used for different types of documents, 
        or are switched by a URL parameter.<br/>
        <br/>
      </li>
      <li>Specify what authentication is required to view the document, if any. 
        This can be IP-based filtering, looking up a username/password in an LDAP 
        database, or using an external login web page.<br/>
        <br/>
      </li>
      <li>If a text query is specified, the <b>Document Request Parser </b>is 
        responsible for structuring that query in the same fashion as crossQuery's 
        <b>Query Request Parser</b>. In fact, it often makes sense for one parser 
        to call the other, or for them to share a common stylesheet that handles 
        parsing duties. </li>
    </ol>
    <p>Suppose a user, through <i><b>crossQuery</b></i>, searches for the word 
      &quot;apartheid&quot;. The top document hit will be the book <u>The Opening 
      of the Apartheid Mind</u> (assuming you've indexed the sample data available 
      with the XTF distribution.) If the user clicks on that title, <i> <b>dynaXML</b></i> 
      is then invoked with a URL like this: </p>
      
    <pre class="Sample"><b> http://<span class="MacroCode">yourserver</span>:8080/xtf/view?docId=mm/ft958009mm/ft958009mm.xml&amp;query=apartheid</b></pre>
    Notice that the first part of the URL (everything before the <b>?</b> symbol) 
    invokes the <b><i>dynaXML</i></b> servlet, and second part of the URL (everything 
    after the <b>?</b> symbol) defines which document to display and a text query 
    to run on it. <br/>
    <br/>
    <table width="90%" cellpadding="0" cellspacing="12">
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">docId=mm/ft958009mm/ft958009mm.xml</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The identifier 
          of the document to view.</span></td>
      </tr>
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">query=apartheid</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The word to 
          search for in the document.</span></td>
      </tr>
    </table>
    <p> The <i><b>dynaXML</b></i> servlet transforms the URL parameters into an 
      XML document, suitable for processing by the <b>Document Request Parser</b> 
      (which is of course written in XSLT.) The parser included with the XTF distribution 
      is called<span class="Code"> docReqParser.xsl</span>, and we'll discuss 
      what it does below.</p>
    <p>The input document will always have the form: </p>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="<span class="MacroCode">ParamName</span>" value="<span class="MacroCode">ParamValue</span>"&gt;
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
           â€¦
  &lt;/param&gt;
      â€¦
&lt;/parameters&gt;</b></pre>
    where <span class="MacroCode">Token</span> specifies a single word, and has 
    the form: <br/>
    <br/>
    <div class="Sample"> <span class="Code"> &lt;token value="<span class="MacroCode">Word</span>" 
      isWord = "<span class="MacroCode">YesOrNo</span>"/&gt; </span> <br/>
      <br/>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">Word</span>" 
          </td>
          <td><span class="BaseStyle">is the actual word or symbol extracted from 
            the URL.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> isWord="<span class="MacroCode">YesOrNo</span>" 
          </td>
          <td><span class="BaseStyle">identifies whether the token is a word or 
            punctuation symbol.</span></td>
        </tr>
      </table>
    </div>
    <br/>
    and <span class="MacroCode">Phrase</span> specifies an entire phrase extracted 
    as a single string, with the form: <br/>
    <br/>
    <div class="Sample"> 
      <pre class="Code">&lt;phrase value="<span class="MacroCode">StringOfWords</span>"&gt;
    <span class="MacroCode">Token</span>
      â€¦
    <span class="MacroCode">Token</span>
&lt;/phrase&gt;
</pre>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">StringOfWords</span>" 
          </td>
          <td><span class="BaseStyle">is the entire phrase extracted from the 
            URL as a single string.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> <span class="MacroCode">Token</span>...<span class="MacroCode">Token</span> 
          </td>
          <td> <span class="BaseStyle"> is the original phrase broken down into 
            individual token tags for each word or symbol in the phrase. </span> 
          </td>
        </tr>
      </table>
    </div>
    <p><br/>
      For the sample URL above, the XML passed to the <b>Document Request Parser</b> 
      looks like this: <br/>
    </p>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="docId" value="mm/ft958009mm/ft958009mm.xml"&gt;
     &lt;token value="mm/ft958009mm/ft958009mm.xml" isWord="yes"/&gt;
  &lt;/param&gt;

  &lt;param name="query" value="apartheid"&gt;
     &lt;token value="apartheid" isWord="yes"/&gt;
  &lt;/param&gt;

&lt;/parameters&gt;</b></pre>
    <p>Our example doesn't have a phrase in it or a multi-word parameter, but 
      if you're curious how those would look, see the example in the section on 
      <a href="#crossQuery_QueryParser_Prog">Query Parser Programming</a> above.</p>
    <p>The sample<span class="Code"> docReqParser.xsl </span>creates the following 
      output based on the input<span class="Code"> &lt;parameters&gt; </span>block.</p>
    <pre class="Sample"><b>&lt;style path="style/dynaXML/docFormatter/default/docFormatter.xsl"/>
&lt;source path="data/mm/ft958009mm/ft958009mm.xml"/>
&lt;index configPath="conf/textIndexer.conf" name="default"/>
&lt;query indexPath="index" termLimit="1000" workLimit="500000">
   &lt;and field="text" maxSnippets="-1" maxContext="80">
      &lt;term>apartheid&lt;/term>
   &lt;/and>
&lt;/query>
&lt;auth access="allow" type="all"/></b></pre>
    <p>Let's analyze this in small pieces.</p>
    <pre class="Sample"><b>&lt;style path="style/dynaXML/docFormatter/default/docFormatter.xsl"/></b></pre>
    <p>The<span class="Code"> &lt;style&gt; </span>tag directs dynaXML to the 
      <b>Document Formatter</b> stylesheet to use for this request. The path is 
      relative to the XTF base directory.</p>
    <pre class="Sample"><b>&lt;source path="data/mm/ft958009mm/ft958009mm.xml"/></b></pre>
    <p>Next, the<span class="Code"> &lt;source&gt; </span>tag identifies the location 
      of the source document that should be displayed. Again the path is relative 
      to the XTF base directory. The sample data is laid out in subdirectories 
      based on deconstructing the document ID, but one could write a parser that 
      used some other strategy for locating documents.</p>
    <pre class="Sample"><b>&lt;index configPath="conf/textIndexer.conf" name="default"/></b></pre>
    <p>For speed, dynaXML includes a facility called &quot;Lazy Trees&quot; which 
      creates a binary representation of the input document on disk. The binary 
      version is much faster to process, especially if the input document is large 
      but the parts of it needed by the <b>Document Formatter</b> are small. In 
      any case, <i><b>dynaXML</b></i> needs to know where to find the Lazy Trees 
      created by the <b><i>textIndexer</i></b>, or where to create them if not 
      found. The<span class="Code"> &lt;index&gt; </span>tag tells it where to 
      find the index configuration file, and the name of the index subset. If 
      you're interested in learning more about Lazy Trees, see <a href="underHood.html#LazyFiles">XTF 
      Under the Hood</a>.</p>
    <pre class="Sample"><b>&lt;query indexPath="index" termLimit="1000" workLimit="500000">
   &lt;and field="text" maxSnippets="all" maxContext="80">
      &lt;term>apartheid&lt;/term>
   &lt;/and>
&lt;/query></b></pre>
    <p>Next comes a query to run against the full text of the document. Of course 
      the query is optional, but if included, its format is exactly the same as 
      the output of <i><b>crossQuery</b></i>'s <b>Query Parser</b>. In fact, the 
      default<span class="Code"> docReqParser.xsl </span>simply uses<span class="Code"> 
      &lt;xsl:import&gt; </span>to incorporate <span class="Code">queryParser.xsl</span>, 
      and uses its templates to do the work of parsing and formatting the text 
      query.</p>
    <p>One curious thing to see here is <span class="Code">maxSnippets=&quot;all&quot;</span>. 
      In this case,<span class="Code"> all </span>is a special value, telling 
      the <b>Text Engine</b> to gather <i>all</i> of the snippets/hits for the 
      given document. If you only wanted the ten best scoring hits, you could 
      specify <span class="Code">maxSnippets=&quot;10&quot; </span>instead.</p>
    <pre class="Sample"><b>&lt;auth access="allow" type="all"/></b></pre>
    <p>The final tag produced by the <b>Document Request Parser</b> is the<span class="Code"> 
      &lt;auth&gt; </span>tag, which specifies authentication to perform. The 
      simplest tag is shown above, and simply allows access to all users. Other 
      authentication mechanisms are available; for more information please consult 
      the section on <a href="deployment.html#UserAuthentication">User 
      Authentication</a> in the XTF Deployment Guide. Multiple<span class="Code"> 
      &lt;auth&gt; </span>tags will be processed in order until one succeeds or 
      fails.</p>
    <p>Customizing the <b>Document Request Parser</b> is beyond the scope of this 
      document, but a good place to start is by incrementally modifying the sample<span class="Code"> 
      docReqParser.xsl </span>included with the XTF distribution.<br/>
    </p>
    <p class="Heading2">Document Formatter Programming<a name="dynaXML_DocFormatter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    The <b>Document Formatter</b> stylesheet receives as its input the requested 
    XML document. For its output it should produce an HTML based document web-page 
    that can be viewed in the user's browser. <br/>
    <br/>
    The XML document passed by the <i><b>dynaXML</b></i> servlet to the Document 
    Formatter stylesheet consists of the original XML source document with the 
    following additions: <br/>
    <ul>
      <li class="ListItem"> Any added <a href="tagRef.html#textIndexer_Tag_Ref">attributes</a> 
        introduced by the <b><i>textIndexer</i></b> <b>Pre-Filter</b> when the 
        document was indexed. <br/>
        <br/>
      </li>
      <li class="ListItem"> If a query accompanied the document request, a<span class="Code"> 
        snippets </span>tag will appear at the top of the document, summarizing 
        of all the hits found within the document, including a configurable amount 
        of surrounding text.<br/>
        <br/>
      </li>
      <li class="ListItem"> If a query accompanied the document request, then 
        zero or more<span class="Code"> <a href="tagRef.html#dynaXML_DocFormatter_Hit">hit</a> 
        </span>and<span class="Code"> <a href="tagRef.html#dynaXML_DocFormatter_Term">term</a> 
        </span>tags will appear around matching text in the main body of the document 
        for the given query. If a hit spans the boundary between one XML element 
        and the next, the<span class="Code"> hit </span>tag will end and a<span class="Code"> 
        <a href="tagRef.html#dynaXML_DocFormatter_More">more</a> 
        </span>tag will resume inside the next element.</li>
    </ul>
    <p> The<span class="Code"> snippets </span> summary tag will have the following 
      form: </p>
    <pre class="Sample"><span class="Code">&lt;xtf:snippets&gt;
  <span class="MacroCode">Snippet</span>
  <span class="MacroCode">Snippet</span>
    â€¦
&lt;/xtf:snippets&gt;</span></pre>
    <p>where each <span class="MacroCode">Snippet</span> is a <b><i>dynaXML</i></b><span class="Code"> 
      <a href="tagRef.html#dynaXML_DocFormatter_Snippet">snippet</a> 
      </span>tag that summarizes one query match in the requested document. </p>
    <p>The additional tags and attributes added by the <b><i>textIndexer</i></b> 
      and the <b><i>dynaXML</i></b> servlet are prefixed with an<span class="Code"> 
      xtf: </span>namespace to clearly differentiate them from other tags in the 
      XML document.</p>
    <p>It should be noted that, unlike the <b>Result Formatter</b> in <i><b>crossQuery</b></i>, 
      the <b>Document Formatter</b> does not receive the<span class="Code"> &lt;parameters&gt; 
      </span>block from the URL request. But if it needs access to the URL parameters, 
      they are always available through global<span class="Code"> &lt;xsl:param&gt; 
      </span>declarations.</p>
    <p>Sometimes it is helpful to view the raw XML that <i><b>dynaXML</b></i> 
      passes to the <b>Document Formatter</b>. To do this, add <span class="Code"> 
      &amp;raw=1 </span>to the URL, and the servlet will bypass the formatter 
      completely and display the raw XML directly in your browser. Beware however 
      that large documents may take quite some time to process and transmit.</p>
    <p></p>
    <p>Writing the <b>Document Formatter</b> can be quite challenging, as many 
      options are possible and the output is very dependent on the structure of 
      the input XML document. In addition, if your collection includes several 
      types of documents, you may need several formatters. Writing XSLT is beyond 
      the scope of this tutorial, but you may get some ideas by examining the 
      sample<span class="Code"> docFormatter.xsl </span>included with the XTF 
      distribution.</p>
    <p>As with everything in XTF, it is advisable (and fun) to start with something 
      simple and then progressively refine the stylesheets over time.</p>
    
  <p class="Heading2">Other Common Tasks<a name="dynaXML_Common_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p>A fully fleshed-out <b><i>dynaXML</i></b> system will need to handle errors 
    gracefully. You may also wish to add session state features (to record data 
    that persists across page views.) Since these tasks are common to both servlets, 
    they are documented in the <a href="#Common_Prog">Common <i><b>crossQuery/dynaXML</b></i> 
    Programming Tasks</a> section below.<br/>
  </p>
  </div>
  <hr/>
<p class="Heading1">Common <i>crossQuery/dynaXML</i> Programming Tasks<a name="Common_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  
<p>The <b><i>dynaXML</i></b> and <b><i>crossQuery </i></b>servlets share some 
  aspects of their operation. Instead of repeating the documentation for these 
  common parts in each section, these common tasks are collected below.</p>
<div class="IndentL"> 
    <p class="Heading2">Error Generator Programming for <i><b>crossQuery</b></i> 
      and<i><b> dynaXML</b></i><a name="Common_ErrorGen_Prog"></a></p>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p>It's not a perfect world, and errors happen. For the times when they do, 
    the <i><b>crossQuery</b></i> and <b><i>dynaXML </i></b>servlets include a 
    handy stylesheet-based mechanism to put a nice face on things, creating a 
    formatted HTML page letting the user know what happened, and potentially how 
    to fix it. This stylesheet is called the <b>Error Generator</b>.</p>
<p>Here are the main sources of errors that activate the servlet's error handling 
  mechanism:</p>
  <ol>
    <li>Configuration errors, such as invalid parameters in the<span class="Code"> 
      crossQuery.conf </span>or<span class="Code"> dynaXML.conf </span>file, or 
      missing stylesheets.</li>
    <li>Errors detected by the<b> Query Parser </b>stylesheet. It lets the servlet 
      know something went wrong by outputting an<span class="Code"> &lt;error&gt; 
      </span>tag instead of the normal<span class="Code"> &lt;query&gt; </span>tag.</li>
    <li>Incorrect syntax in the<span class="Code"> &lt;query&gt; </span>tag produced 
      by the <b>Query Parser</b>.</li>
    <li>Incorrect syntax in the tags produced by the <b>Document Request Parser</b>.</li>
    <li>Problems that occur while the<b> Text Engine </b>is reading the input 
      document or executing a query. Some such errors include trying to query 
      a document that hasn't been indexed, or attempting a wildcard query on too 
      many terms.</li>
    <li>Bugs in the XTF system itself (hopefully very rare.)</li>
  </ol>
  <p>In all these cases, the servlet looks in the<span class="Code"> crossQuery.conf 
    </span>or<span class="Code"> dynaXML.conf </span>file for the<span class="Code"> 
    &lt;errorGen&gt; </span>tag that specifies an <b>Error Generator </b>stylesheet 
    to run. The servlet constructs a small input document with details about the 
    particular error and passes it to the <b>Error Generator</b>, whose job is 
    to output a nice-looking error page.</p>
<p>The following query will create an error with the sample distribution (it performs 
  a wildcard query on all terms): </p>
<div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/search?text=* 
  </span> </div>
<p>This exceeds the default limit on the number of terms a query can access, so 
  <i><b>crossQuery </b></i>calls the <b>Error Generator</b> with the following 
  input:</p>
<pre class="Sample"><b>&lt;TermLimit>
   &lt;message>
     Wildcard query on 'text' matched too many terms (more than 1000). 
     First 50 matches: $ + 0 0.0 0.00 0.0001 0.001 0.0015 0.0029 0.003 
     0.0034 0.004 0.005 0.006 0.007 0.008 0.009 0.01 0.010 0.011 0.012 
     <span class="MacroCode">...more terms here...
</span>   &lt;/message&gt;
&lt;/TermLimit></b></pre>
<p>Writing the XSLT code that transforms the various error tags is beyond the 
  scope of this document, but the default <b>Error Generator</b> included with 
  the XTF distribution is a good place to start. It can be found in the<span class="Code"> 
  style/crossQuery </span>directory. </p>
  <p>An easy way to check the input to your <b>Error Generator</b> is to add<span class="Code"> 
    &amp;raw=1 </span>to your query URL. When an error occurs, the servlet will 
    dump the raw XML to the browser, instead of sending it to the stylesheet.</p>
  <p>Each kind of error specifies different information for the <b>Error Generator</b> 
    to work on. For instance, authentication failures include the requestor's 
    IP address, whereas internal errors include a Java stack trace. For a full 
    list of the various errors that may be sent by <i><b>crossQuery </b></i>to 
    the <b> Error Generator</b>, please consult the <a href="tagRef.html#Error_Generators">Error 
    Generator Stylesheet Reference</a>.</p>

  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p class="Heading2">Pass-Through Configuration Tags<a name="Common_PassThrough"></a></p>
  <p>
    XTF's configuration files (such as <span class="Code">textIndexer.conf</span>,
    <span class="Code">crossQuery.conf</span>, etc.) are of course used to
    control operation of the various tools. But you can also use these files
    to configure your own stylesheets. Essentially, you can add any tag you
    like to the configuration file, and then you can access it later in your
    stylesheets. In this way, you can centralize all the parameters you might
    wish to control in one place.
  </p>
  <p>
    For instance, let's say we add the following to <span class="Code">crossQuery.conf</span>:
  </p>
  <pre class="Sample"><b>&lt;fruit-color value="purple"/></b></pre>
  <p>
    Now the <span class="Keyword">crossQuery</span> servlet will make the new
    parameter <span class="Code">fruit-color.value</span> available to every
    stylesheet it runs, including the <b>Query Parser</b>, <b>Result Formatter</b>,
    and <b>Error Generator</b> stylesheets. A stylesheet can access it like this:
  </p>
  <pre class="Sample"><b>&lt;xsl:param name="fruit-color.value"/></b></pre>
  <p>
    Note that the name for the parameter consists of <i>both</i> the element name
    and the attribute name.
  </p>
  
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p class="Heading2">Tracking Session State<a name="Common_Session_State"></a></p>
    <p>By default, <i><b>crossQuery </b></i>and <i><b>dynaXML </b></i>are &quot;stateless&quot;, 
      that is, they don't remember anything from one request to the next. Any 
      given URL request is treated separately, and all the servlet knows is what 
      is present in the URL parameters.</p>
    <p>URL parameters are fine for small pieces of data that change frequently, 
      such as query parameters, page number, document ID, etc. However they're 
      cumbersome for large amounts of data, or information that doesn't change 
      frequently. This is where <i><b>XTF</b></i>'s <b>Session State Tracking</b> 
      facilities come in handy.</p>
    <p>Once session tracking enabled, XTF will associate a session ID with the 
      first request made by a particular user. As the user clicks on links from 
      that page, the session ID will automatically track along with each page 
      view. Your parsing and formatting stylesheets can store and retrieve data 
      in the session, and this data will be available on subsequent requests.</p>
    <p>A brief tutorial on session tracking follows; details of the functions 
      are detailed in the <a href="tagRef.html#Session_State">Session 
      State</a> section of the XTF Stylesheet Reference.<br/>
    </p>
    <div class="IndentLR"> 
      <p class="Heading3">Enabling Session Tracking</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        Before attempting to store or retrieve session data, you must enable session 
        tracking in the configuration file of the servlet(s) you're using (i.e.<span class="Code"> 
        dynaXML.conf </span>and/or<span class="Code"> crossQuery.conf</span>). 
        The line to enable tracking looks like this:</p>
      <div class="Sample"> <span class="Code"> </span> <span class="Code">&lt;<b>trackSessions 
        track=&quot;yes&quot;</b>/&gt; </span></div>
      <p class="Heading3">Storing and Retrieving Session Data</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        Once enabled, XTF's built-in XSL extension functions can be used to store 
        or retrieve data in the session associated with a given request. For example, 
        here's some XSL code to store a value in the session:</p>
      <pre class="Sample"><b>&lt;xsl:stylesheet <span class="Red">xmlns:session="java:org.cdlib.xtf.xslt.Session</span>"<span class="MacroCode">...</span>&gt;<span class="MacroCode">
...</span>
  &lt;xsl:value-of select="<span class="Red">session:setData</span>('<span class="MacroCode">someName</span>', '<span class="MacroCode">someValue</span>')"></b></pre>
      <p>As you see, the<span class="Code"> session:setData </span>function can 
        be used like any other XPath function, as long as the proper namespace 
        has been declared. It places data into the session under the given name 
        (replacing any previous data with that name.)</p>
      <p>In general the session data can contain as many name/value pairs as you 
        wish to place into it. The the value can be either a string or structured 
        XML; if you use XML that contains more than one element, be sure to include 
        a single outer wrapper element as in the following example:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;newValue&quot;&gt;
  <span class="Red">&lt;myWrapper&gt;</span>
    &lt;element1&gt;<span class="MacroCode">...</span>&lt;/element1&gt;
    &lt;element2&gt;<span class="MacroCode">...</span>&lt;/element2&gt;
    <span class="MacroCode">...</span>
  <span class="Red">&lt;/myWrapper&gt;</span>
&lt;/xsl:variable&gt;

&lt;xsl:value-of select="session:setData('<span class="MacroCode">someName</span>', $newValue)"></b></pre>
      <p></p>
      <p>Retrieving session data is also very simple:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;myData&quot; select=&quot;<span class="Red">session:getData</span>('<span class="MacroCode">someName</span>')"></b></pre>
      <p></p>
      <p>The<span class="Code"> session:getData </span>function retrieves the 
        data value established for this name by<span class="Code"> session:setData</span>. 
        If no data was previously stored under that name, null is returned. (i.e. 
        empty string/empty sequence). </p>
      <p class="Heading3">The Session ID and How it is Tracked</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        XTF automatically creates and tracks session identifiers for you. In general 
        you don't have to do any additional work for this to happen transparently 
        in the background. However, one case may require more work.</p>
      <p>By default, when session tracking is enabled, XTF attempts to set a cookie 
        in the user's browser. This cookie simply contains the session ID, and 
        is timed to expire at the end of the user's browsing session. On subsequent 
        requests, the browser will automatically return the cookie to XTF, providing 
        the session ID.</p>
      <p>However, some users disable cookies due to privacy concerns. If XTF detects 
        that the cookie was not accepted, it automatically switches to using the 
        URL to store the session identifier. Typically you'll see &quot;<span class="Code">;jsessionid=<span class="MacroCode">xxxxx</span></span>&quot; 
        added to the URL in this case, just before the '<span class="Code">?</span>' 
        that begins the normal URL parameters.</p>
      <p class="Heading3">URL Encoding of the Session ID</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        When URL encoding is activated, XTF automatically intercepts URLs that 
        your stylesheets produce as part of<span class="Code"> &lt;form&gt;</span>,<span class="Code"> 
        &lt;a&gt;</span>, and<span class="Code"> &lt;frame&gt; </span>elements 
        in the output HTML. XTF will then add the session ID to the URLs as appropriate. 
      </p>
      <p>Though not common, if your HTML output contains URLs as part of other 
        elements or in JavaScript calls, then you'll need to inform XTF that these 
        URLs may need to have the session ID added. This is done using the<span class="Code"> 
        session:encodeURL </span>function like this:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;originalURL&quot; select=&quot;<span class="MacroCode">some value here</span>&quot;/&gt;
&lt;xsl:variable name=&quot;encodedURL&quot; select=&quot;<span class="Red">session:encodeURL</span>($originalURL)&quot;/&gt;</b> </pre>
      <p>XTF will check the URL and if it points to an XTF servlet and the session 
        ID needs to be tracked in the URL, it will return a modified version of 
        the URL that contains the session ID.</p>
      <p class="Heading3">Getting the session ID</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        You may want to record the identifier of the current session for reference 
        in a database. To obtain the identifier, use code like this:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;sessionID&quot; select=&quot;<span class="Red">session:getID()</span>&quot;/&gt;</b> </pre>
      <p class="Heading3">Checking Whether Session Tracking is Enabled</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        If you wish, you can create stylesheet code that works differently depending 
        on whether session tracking is enabled in the configuration file for the 
        particular servlet you're working in. It looks like this:</p>
      <pre class="Sample"><b>&lt;xsl:if test=&quot;<span class="Red">session:isEnabled()</span>&quot;&gt;
  &lt;!-- Do session-related stuff here --&gt;
&lt;/xsl:if&gt;</b> </pre>
      <p></p>
      <p>&nbsp;</p>
    </div>
  
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p class="Heading2">Calling Command-line Tools<a name="Common_Exec"></a></p>
    <p>
      It can be very handy to utilize external (even non-Java)
      applications within your stylesheets. To facilitate this, XTF provides a
      mechanism for your stylesheet to call any command-line program. The stylesheet
      can send input and receive output in either plain text or XML.
    </p>
    <p>
      This is accomplished using XTF's built-in 
      <span class="Code">exec:run</span> XSL extension element. It can call any
      command-line tool installed on the same machine on which the
      servlet container is running. For example, 
      here's some XSL code that will pause for 10 seconds on a UNIX machine:</p>
    <pre class="Sample">&lt;xsl:stylesheet <span class="Red">xmlns:exec="java:/org.cdlib.xtf.saxonExt.Exec"</span><span class="MacroCode">...</span>&gt;<span class="MacroCode">
...</span>
  &lt;exec:run command="sleep" xsl:extension-element-prefixes="exec">
    &lt;exec:arg>10&lt;/exec:arg>
  &lt;/exec:run></pre>
    <p>
      Now let's look at a more complicated example, in which was pass in some XML data
      to the UNIX <span class="Code">sed</span> tool. We ask it to perform a simple
      text replacement and return the result, which was gather in XML form into an
      XSLT variable.
    </p>
    <pre class="Sample">&lt;xsl:variable name="myText">
  &lt;exec:run command="sed" xsl:extension-element-prefixes="exec">
    &lt;exec:arg><span class="YellowBG">s/floor/chimney/</span>&lt;/exec:arg>
    &lt;exec:input>
      &lt;job>I work as a <span class="YellowBG">floor-sweep</span>.&lt;/job>
    &lt;/exec:input>
  &lt;/exec:run>
&lt;/xsl:variable></pre>
    <p>
      After this runs, the variable <span class="Code">myText</span> will contain
      the XML element <span class="Code">&lt;job>I work as a <span class="YellowBG">chimney-sweep</span>.&lt;/job></span>
    </p>
    <p>
      XTF automatically determines if the data you pass to an external program
      is XML and serializes it as text. If it's just a string, that string is
      passed verbatim to the external program. Likewise, XTF parses the output from
      the external program, and if the output looks like XML then XTF will
      parse it as such; otherwise, the results will come back in the form of
      a string. In this way, you have the flexibility to work with any command-line
      tool whether or not it understands XML.
    </p>
    <p>
      The <span class="Code">exec</span> element is also capable of killing the
      external tool if it takes too long to finish. 
      For details, see the <a href="tagRef.html#Exec">XTF Tag Reference</a> section.
    </p>
    
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p class="Heading2">Checking a File's Existence, Length, and Modification Time<a name="Common_FileUtils"></a></p>
    <p>
      XSLT allows a stylesheet to easily pull in the contents of an XML file, by
      using the <span class="Code">document()</span> function. However, it does
      not provide a convenient way to check whether the file exists before opening it,
      nor to find out its length or the time it was last modified. While these
      could be accomplished using Saxon's default ways of using any Java class, it
      would be quite clumsy. Instead, XTF provides a
      set of XSLT extension functions to fill this functionality gap.
    </p>
    <p>
      Here's an example showing how we can check for a file's existence:
    </p>
    <pre class="Sample">&lt;xsl:stylesheet <span class="Red">xmlns:FileUtils="java:org.cdlib.xtf.xslt.FileUtils"</span>>
  â€¦
  &lt;xsl:variable name="filename"
    select="concat('../../', $sourceDir, $docId, '.mets.xml')"/>
  &lt;xsl:choose>
    &lt;xsl:when test="<span class="Red">FileUtils:exists($filename)</span>" >
      &lt;xsl:message>File exists.&lt;/xsl:message>
    &lt;/xsl:when>
    &lt;xsl:otherwise>
      &lt;xsl:message>File doesn't exist.&lt;/xsl:message>
    &lt;/xsl:otherwise>
  &lt;/xsl:choose></pre>
    <p>
      In this way you can put together a filename, check whether the file
      exists, and perform different actions depending on that check. XTF
      also provides functions to find out the length of a file, and to
      determine the last time it was modified. For more information,
      please refer to the <a href="tagRef.html#FileUtils">XTF Tag Reference</a> 
      section on <span class="Code">FileUtils</span>.
    </p>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p class="Heading2">Redirecting to another URL<a name="Common_Redirect"></a></p>
    <p>
      You may encounter scenarios where the best thing to do isn't to generate
      the output for a given query or document request, but rather to redirect
      the user's browser to a different URL. While this can be done in the
      <span class="Code">&lt;meta></span> tag of the output HTML document, that
      method is not very clean. In particular, it prevents the "Back" button in
      the user's browser from working properly. If they hit the "Back" button,
      the browser simply encounters the redirect again, effectively blocking the
      user from getting back to where they came from.
    </p>
    <p>
      The preferable method for redirecting is to generate an HTTP 302 status
      code. But how can a servlet do that? By using an XTF extension built just
      for this purpose. Here's an example of redirecting to a new URL:
    </p>
    <pre class="Sample">&lt;redirect:send url="http://<span class="MacroCode">another_URL_here</span>" 
               xmlns:redirect="java:/org.cdlib.xtf.saxonExt.Redirect" 
               xsl:extension-element-prefixes="redirect"/></pre>
    <p>
      This needs to be placed fairly early in the result or document formatter, before
      any other output. The redirect needs to be the first output; even having an
      HTML header before it will cause an exception to be thrown. Once the redirect
      instruction is executed, further stylesheet processing is aborted and the
      user is immediately taken to the new URL. For more information, see the
      <a href="tagRef.html#Redirect">XTF Tag Reference</a> 
      section on <span class="Code">Redirect</span>.
    </p>
  
  </div>
  
  <!-- Common --> 
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --><br/>
</div>
</body>


</html>
